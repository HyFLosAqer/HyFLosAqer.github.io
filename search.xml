<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序</title>
      <link href="/2022/07/07/pai-xu/"/>
      <url>/2022/07/07/pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="几种慢速排序方法"><a href="#几种慢速排序方法" class="headerlink" title="几种慢速排序方法"></a>几种慢速排序方法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的思想主要是交换排序</p><p>**基本思想:**两两比较相邻记录的关键字,如果反序就交换,直到没有反序的记录为止</p><p>**时间复杂度:**O(n<sup>2</sup>)      最小值n-1次查找      最大值n(n-1)/2次查找且做等量级移动</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>简单选择排序(Smple Selection Sort)就是通过<strong>n-i次关键字间</strong>的比较,从n-i+1个记录中选择出关键词最小的记录,并和第i个记录进行交换 ( 1&lt;= i &lt;=n )</p><p>**时间复杂度:**O(n<sup>2</sup>), </p><p>比较次数恒定为n(n-1)/2</p><p>交换次数最小为0，最大为n-1</p><p>复杂度相对于冒泡排序略低  </p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序就是将一个记录插入已经排好序的有序表中,从而得到一个新的、记录数＋1的有序表</p><p><strong>时间复杂度：</strong>O(n<sup>2</sup>)</p><p>平均的比较和移动次数为<strong>n<sup>2</sup>/2</strong>，性能高于直接插入和冒泡</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>先简单介绍下<strong>基本有序</strong>：最小的关键词基本在前面，不大不小的基本在中间，最大的基本在后面</p><p>因此我们采用<strong>跳跃分割</strong>的策略：将相距某个<strong>增量</strong>的记录组成一个子序列，在子序列进行插入排序后就是基本有序，使得排序效率提高。</p><p>性能主要取决于<strong>增量</strong>的值，研究指出为dlta[k]=2<sup>t-k+1</sup>-1（0&lt;=k&lt;=t&lt;=log<sub>2</sub>(n+1)）时效率较高,<strong>时间复杂度：</strong>O(n<sup>3/2</sup>)</p><h2 id="堆积法"><a href="#堆积法" class="headerlink" title="堆积法"></a>堆积法</h2><p>堆是具有下列性质的完全二叉树</p><ul><li>每个结点的值都大于或者等于其左右孩子结点的值，成为大顶堆</li><li>每个结点的值都小于或者等于其左右孩子结点的值，成为小顶堆</li></ul><h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>以大顶堆为例子</p><ul><li>将待排序数组构成一个大顶堆，将顶端结点和堆数组末尾互换</li><li>将剩余的n-1个序列重新构成一个大顶堆，得到n-1中的次大值</li><li>重复上述</li></ul><p>问题在于<strong>大顶堆的构建</strong>和<strong>剩余元素重构大顶堆</strong></p><p>具体算法略过，讨论一下算法的复杂度</p><ul><li><p>堆构建的时间复杂度复杂度为：<em><strong>O（n）</strong></em></p></li><li><p>单次重构的时间复杂度为：<em><strong>O（logi）</strong></em>，堆顶获取n-1次。</p><p>总体花费：<em><strong>O（nlogn）</strong></em></p></li></ul><p>综上堆排序时间为<em><strong>O（nlogn）</strong></em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>堆排序空间占用较高，但是排序依旧不够稳定（记录的跳跃性），不适合待排序序列较少的情况</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>2路归并排序的原理是</p><ul><li>假设初始序列有n个记录，则可以看成是n个有序的子序列，每个子序列长度为1</li><li>然后两两归并，得到 n/2 个长度为2 或者为 1 的有序子序列</li><li>重复两两并归</li></ul><p><strong>复杂度分析</strong></p><p>时间复杂度：<em><strong>O（nlogn）</strong></em></p><p>空间复杂度：<em><strong>O（n+logn）</strong></em>  递归情况</p><p>​<em><strong>O（n）</strong></em>  非递归情况   因此最好使用非递归算法</p><p>属于比较占用内存但是效率高且稳定的算法</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序属于从冒泡排序进阶而来</p><p>快速排序的思想：</p><p>通过一趟排序将待排记录分割为两部分，一部分的关键字比另一部分小，将这两部分记录继续进行排序。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>temp<span class="token punctuation">,</span>t<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&gt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        i<span class="token operator">=</span>low<span class="token punctuation">;</span>        j<span class="token operator">=</span>high<span class="token punctuation">;</span>        <span class="token comment">//temp就是基准位</span>        temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//先看右边，依次往左递减</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//再看左边，依次往右递增</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">&gt;=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果满足条件则交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>        <span class="token comment">//最后将基准为与i和j相等位置的数字交换</span>         arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment">//递归调用左半数组</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//递归调用右半数组</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">62</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>时间复杂度:</p><p>最好的情况 <em><strong>O（n）</strong></em></p><p>最坏的情况 <em><strong>O（n<sup>2</sup>）</strong></em></p><p>平均时间复杂度为 <em><strong>O（nlog<sub>2</sub>n）</strong></em></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>将快速排序的递归实施尾递归优化</li><li>优化选取中间值的方法(三数取中、九数取中)</li><li>小数组是，high或者low的值小于7（也有资料显示50），使用直接插入求解</li><li>优化不必要的交换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列查找表(哈希表)</title>
      <link href="/2022/07/05/san-lie-cha-zhao-biao-ha-xi-biao/"/>
      <url>/2022/07/05/san-lie-cha-zhao-biao-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="散列查找表"><a href="#散列查找表" class="headerlink" title="散列查找表"></a>散列查找表</h1><p>之前我们的查找,都需要通过比较a[i] 和 key</p><ul><li><p>顺序查找的方式是 “=” 还是 “!=”</p></li><li><p>折半查找的方式是 “&gt;” 还是 “&lt;”</p></li><li><p>在树的结构中依旧包含了 &lt;  &gt;  =</p></li></ul><p>无论如何比较都不可避免,能否存在直接通过关键词key找到记录的内存存储位置呢?</p><p>这就是我们要讨论的<strong>散列技术</strong></p><h2 id="散列技术"><a href="#散列技术" class="headerlink" title="散列技术"></a>散列技术</h2><p>散列技术是在记录的位置和它的关键字之间建立一个确定的对应关系  <em><strong>f</strong></em></p><p>使得每个关键字key都有对应的存储位置   <em>f(key)</em></p><p>在这里我们把这种对应关系 <em>f</em> 称为<strong>散列函数</strong>,又称为<strong>哈希(hash)函数</strong></p><p>根据这种思想,采用散列技术将记录存储在一块<strong>连续</strong>的存储空间中,这块连续存储空间称之为<strong>散列表</strong>或者<strong>哈希表</strong>,关键字所对应的记录存储位置我们称之为<strong>散列地址</strong></p><h2 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h2><ul><li>在存储时,通过散列函数计算记录的散列地址,按此地址存储该记录</li><li>在查找时,通过散列函数计算记录的散列地址,按此散列地址访问该记录</li></ul><p>所以,<strong>散列函数既是一种存储方法,也是一种查找方法</strong></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对比其他查找结构</p><ul><li>线性表、树、图都具有一定的逻辑关系</li><li>散列技术记录之间没有逻辑关系，记录只与关键字有关</li></ul><p>因此 散列表是面向查找的存储结构，最适合求解的问题：<strong>查找与给定值相等的记录</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>hash表的重点是设计一种简单、均匀、存储利用率高的的散列函数</p><p>如果出现了key<sub>1</sub> != key<sub>2</sub> ，但是<em>f</em>(key<sub>1</sub> )  = <em>f</em>(key<sub>2</sub> ) ，这种表现称之为哈希冲突（collision）,并且把key<sub>1</sub>和key<sub>2</sub> 称之为这个散列函数的同义词（synonym）</p><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>优秀散列函数的定义：</p><ol><li>计算简单（起码低于其他查找技术和关键字比较的时间）</li><li>散列地址的均匀分布 （保证存储空间有效利用、减少处理哈希冲突的时间）</li></ol><p>以下介绍几种常见的散列构造函数（有些类似于密码学，将原来的数字按某种规律变成另一个数字）</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址<br>$$<br>f(key) = a*key + b<br>$$</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>例如身份证号码，前几位数字相同，后几位数字运用散列函数</p><p>**抽取方法:**使用关键字的一部分来计算散列函数</p><p><strong>使用范围：</strong>适合处理关键字特别多、事先知道关键字的分布、关键字若干位<strong>分布</strong>均匀</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p><strong>用法：</strong>将关键字平方之后取中间三位数</p><p><strong>适用：</strong>不知道关键字分布、位数不多</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p><strong>用法：</strong>将关键字从左到右分割成位数相等的几部分（最后一部分可以小一些），这这几部分相加求和，根据散列表长，取最后几位为散列地址</p><p>如果分布不均匀，可以将数据反转一下，如将下表的987 转为789</p><blockquote><p>若散列表长为3</p><p>987654321—— 987 + 654 + 321 + 0 = 1962</p><p>求最后三位为 962</p></blockquote><p><strong>适用：</strong>不需要知道关键字分布、关键字比较多</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>最常用的散列函数，对一个散列表长度为m的散列函数公式为，mod为取余数<br>$$<br>f(key) = key;mod ,p(p&lt;=m)<br>$$</p><ul><li>不仅可以对关键字直接取模，也可以折叠、平方后再取模</li><li>关键的方法在于选择合适的P，减少hash冲突</li><li>根据经验，p为小于或者等于表厂m（最好接近m）的<strong>最小质数</strong>或者不包含小于20质因子的合数</li></ul><h4 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h4><p><strong>用法</strong><br>$$<br>f(key) = random(key)<br>$$<br><strong>适用：</strong>关键字长度不等</p><p><strong>random函数考虑因素</strong></p><ul><li>计算散列地址的时间</li><li>关键字长度</li><li>散列表大小</li><li>关键字分布情况</li><li>记录查找的频率</li></ul><h2 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h2><p>哈希冲突在所难免，所以有了后续的处理方法</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p><strong>所谓开放地址法就是发生了哈希冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并记录</strong><br>$$<br>f1（key）=(f(key) + di)MOD;m:(di=1、2、3、4…….m-1)<br>$$<br>简单得说，就是在hash地址冲突时，将计算出的结果地址向下延续n位，直到有空位</p><p><strong>我们将这种解决冲突的开放地址法称之为线性探测法</strong></p><ul><li>本来就不是同义词的关键字取争夺同一个地址时，我们称之为<strong>堆积</strong></li><li>堆积的出现大大影响了查找和记录的效率</li></ul><p>为此还有其他的开放地址方法</p><ul><li><p>二次探测法：将d<sub>i</sub>的递增改为平方</p><p>其中d<sub>i</sub>=1、-1、2、-2、4…….q<sup>2</sup>、-q<sup>2</sup>（q &lt;= m/2）</p></li><li><p>随机探测法：d<sub>i</sub>是一个随机数列</p></li></ul><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>发生hash冲突时采用备用的散列函数</p><p>优势是使得关键字不发生集聚，缺点是增加了计算时间</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>散列地址变成指针指向一个单链表</p><p>缺点是带来了查找时遍历单链表的性能损耗</p><h3 id="公共溢出法"><a href="#公共溢出法" class="headerlink" title="公共溢出法"></a>公共溢出法</h3><p>将所有冲突的关键字存入一个公共的溢出区来存放</p><p>查找时先计算散列地址的值，比较后若是相等就取出；如果不相等就去溢出区进行顺序查找</p><p><strong>适用于冲突比较少的情况</strong></p><h2 id="查找实现"><a href="#查找实现" class="headerlink" title="查找实现"></a>查找实现</h2><ul><li>首先定义散列表结构和基本常数</li><li>对散列表进行初始化</li><li>定义散列函数（函数可以更具情况更改算法）</li><li>插入时计算散列地址，若地址存在关键字，进行hash冲突处理</li><li>查找和插入类似，额外做一个不存在关键字的判断</li></ul><h2 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h2><p>如果没有冲突，hash表的时间复杂度为最低 :  <em><strong>O（1）</strong></em></p><p>可惜哈希冲突在所难免，需要额外处理的计算，那么平均查找长度取决哪些因素呢？</p><p>其中散列函数<strong>是否均匀</strong>对查找性能是几乎不用考虑的，其主导的有以下</p><h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h3><p>这个浅显可以理解</p><h3 id="散列表的填装因子"><a href="#散列表的填装因子" class="headerlink" title="散列表的填装因子"></a>散列表的填装因子</h3><p><strong>填装因子α：</strong>填入表中的记录个数/散列表长度</p><p>其中α表示散列表的装满程度，α越大，发生哈希冲突的情况越多</p><p>为此我们在了解记录个数n的情况下，总可以选择一个合适的填装因，以便将平均查找长度限定在一个长度范围内。通常是将散列表空间设置得比查找集合大，一牺牲空间换取时间效率</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多路查找树(B树)</title>
      <link href="/2022/07/03/duo-lu-cha-zhao-shu-b-shu/"/>
      <url>/2022/07/03/duo-lu-cha-zhao-shu-b-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h1><p><strong>概念 :</strong> </p><p>回忆起AVL树</p><ul><li><p>每一次插入或删除总是为了保持树的平衡性而旋转,增加了性能的消耗。</p></li><li><p>一个结点只能存储一个元素，在元素非常多时，树的高度和度非常大，使得<strong>内存存取外存</strong>次数多</p></li></ul><p>所以，我们引入了一种<strong>绝对平衡</strong>且单结点可以存储<strong>多个元素的</strong>树，即为多路查找树</p><p><strong>具体实现</strong></p><ul><li>2-3树</li><li>2-3-4树</li><li>B树</li><li>B+树</li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>2-3以及之后的2-3-4树都属于特殊的B树</p></li><li><p>其<strong>任意节点</strong>到它所有<strong>叶子节点的深度</strong>都是相等的</p></li><li><p>每一个结点有<strong>2个(2结点)<strong>或者</strong>3个(3结点)</strong></p><ul><li><p>一个2结点包含一个元素,两个孩子</p><p>构成与二叉树类似,不过只存在<strong>空树</strong>或者<strong>满树</strong>(两个孩子)</p></li><li><p>一个3结点包含一大一小两个元素,三个孩子</p><p>值的比较：<strong>L&lt;P1&lt;M&lt;P2&lt;R</strong></p><p>同时也只能存在空树或者满树</p></li></ul></li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>类似于二叉树，插入操作发生在<strong>叶子结点</strong>，不同的是会发生结构的连锁反应</p><p>有一下几种情况，用近python格式伪码呈现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 插入叶子结点C是二结点树        C成为三结点树        <span class="token keyword">return</span>    <span class="token keyword">if</span> 插入叶子结点C是三结点树<span class="token keyword">if</span> 双亲P是二结点树        P成为三结点树        <span class="token keyword">return</span>    <span class="token keyword">if</span> 双亲P是三结点树P拆分为两颗二结点树        <span class="token keyword">or</span>         整个树的高度增加    <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>插入的逆过程</p><ul><li><strong>第一种情况：</strong>删除的叶子结点属于3结点的位置（双亲属于3结点树）</li></ul><p>​ 直接删除，3结点变2结点</p><ul><li><p><strong>第二种情况：</strong>删除的叶子结点C属于2结点的位置</p><p>分四种情况</p><ul><li>双亲<strong>2结点</strong>，有个<strong>3节点</strong>的孩子（C的兄弟）<strong>：</strong>删除C，以双亲进行旋转</li><li>双亲<strong>2结点</strong>，有个<strong>2节点</strong>的孩子（C的兄弟）<strong>：</strong>删除C，以双亲的双亲进行旋转</li><li>双亲<strong>3结点：</strong>删除C，双亲拆分为2个2结点树</li><li>满二叉树<strong>：</strong>删除C，降低树的层数</li></ul></li><li><p><strong>第三种情况：</strong>删除的节点非叶子结点</p></li></ul><p></p><p>​中序遍历该结点的前驱或者后驱元素，进行补位</p><h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>属于23树的拓展，基本属性相同，多了一个<strong>4结点</strong>的使用。</p><p>其包含了小中大三个元素和4个孩子（或者没有孩子）</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种平衡的多路查找树，结点最大的孩子数目为B树的阶（order）</p><p>可以先从下面的2-3树开始理解，再看B树的内容</p><p>一个m阶的B树具有如下属性</p><ul><li><p>如果根结点不是叶结点。则至少有两颗树</p></li><li><p>每个非根的分支结点都有k-1个元素和K个孩子,每一个叶子结点n都有k-1个元素</p><p>其中  <code>(m/2) &lt;= k &lt;= m</code>     其中 / 取整</p></li><li><p>所有叶子结点都位于同一层次</p></li><li><p>与其他平衡二叉树类似，B-树查找、插入和删除操作的时间复杂度为<em><strong>O(logn)</strong></em> 量级</p><p>其中数据排列具有以下特征</p></li><li><p>所有分支结点包含以下数据信息(n,A<sub>0</sub>,K<sub>1</sub>,A<sub>1</sub>,K<sub>2</sub>,A<sub>2</sub>……K<sub>n</sub>,A<sub>n</sub>)</p></li><li><p>n为关键字个数    <code>(m/2)-1 &lt;= n &lt;= m-1</code>  </p></li><li><p>所有的A、K同下标正相关</p></li><li><p>​      A<sub>n-1</sub>   &lt;=     K<sub>n</sub>    &lt;=    A<sub>n</sub>  </p><p><img src="https://user-images.githubusercontent.com/105496252/177155333-0797edde-8e40-406e-aa9f-05f4f7dad702.jpg" alt="B树结构特征"></p></li></ul><h3 id="结构优势"><a href="#结构优势" class="headerlink" title="结构优势"></a>结构优势</h3><p>减少内存与外存的的数据交换次数(例如减少硬盘读写)</p><p>同时数据内容过于庞大不能够一次性读进内存</p><p>可以说是专门为<strong>内外存</strong>数据交互准备的</p><ul><li><p>将B树阶数同硬盘存储页面大小相匹配</p><p>例如: 1001阶、高度2的树，可以存储10亿个关键字</p></li><li><p>将根结点永久保存在内存中</p></li><li><p>查找某个关键字至多需要2次硬盘读写</p></li></ul><p>对于查找n个关键字的m阶B树，查找一个数据，仅仅支持<strong>随机查找</strong></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>b树虽然利于内外村交互，但是再查找过程中，对于硬盘的遍历还是存在缺陷的。</p><p>再中序遍历中，尤其是再孩子都处于不同硬盘页面时，会进行多次的页面转换、重复遍历（尤其是对<strong>结点</strong>也可以说是双亲的元素）</p><p>为了解决多次遍历的问题，引入了B+树</p><p><img src="https://user-images.githubusercontent.com/105496252/177320624-f955406f-1e44-4f39-9be6-9cd31fe56d46.png" alt="B+树"></p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>对比b树</p><ul><li>有n棵树的结点有n个关键字</li><li>所有叶子结点包含全部关键字的信息，以及指向这些关键字记录的指针，叶子结点本身依据关键字大小从小到大顺序链接</li><li>所有的分支结点可以看成索引，记录了叶子子女的最大（或者最小）元素</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>可以进行随机查找（方式同B树一样，从根结点开始），但是在非子树上的只能是索引，只会找到叶子结点才会停止</li><li>可以进行顺序查找，直接从最左叶子结点开始，适合带有范围的查找</li></ul><h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><p>同B树类似，不过全体在叶子结点进行</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2022/07/03/er-cha-shu-cha-zhao/"/>
      <url>/2022/07/03/er-cha-shu-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有序线性存储表(顺序存储)，在<strong>查找</strong>方面有效率的优势，但是在<strong>插入</strong>和<strong>删除</strong>方面，却选哟花费大量时间。为了照顾插入和删除的效率，同时实现高效率的查找算法，我们引入了二叉树。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉查找树</strong>又称之为<strong>二叉排序树</strong>，它可以为空树，也可以是具有以下特征的二叉树</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它根节点的值</li><li>若右子树不空，则右子树上所有结点的值均大于它根结点的值</li><li>左右子树也为二叉树</li><li>没有键值相等的点</li></ul><p><strong>（越往左越小）</strong></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从某node开始查找，如果目标值小于结点，则往左查找；如果目标值大于结点，往右查找。</p><p>一直找到叶子结点没有找到，返回false</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//伪码 使用递归</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 一直找到叶子节点，还没有找到就返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// 一条路径查找</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment">// 如果找到就返回true</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得知查找一个值为固定的一条路线，效率较高（理论上100的数据量，找到目标值最多需要7次）</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在查找的基础上，找到叶子结点</p><ul><li>如果插入的值等于叶子结点，返回false</li><li>如果插入值大于叶子结点，生成该叶子节点的右侧子树（反之亦然）</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>请神容易送神难，查找到目标结点容易。若是目标结点拥有子孙后代，删除该结点，就会让子孙树游离，原本的对应的关系不正确了。</p><p>删除结点有以下几种情况</p><ol><li>叶子结点</li><li>仅有左或右树结点</li><li>左右树都有的结点</li></ol><p><strong>第一种情况</strong></p><p>直接查找到该结点删除</p><p><strong>第二种情况</strong></p><p>查找到目标结点，其子树替补该位置</p><p><strong>第三种情况</strong></p><p>删除方法主要的概念是<strong>找删除结点前驱结点替换的方法</strong>（后继结点的方法也雷同）</p><ul><li>找到删除结点前驱结点中<strong>数值</strong>最接近的结点childNode（左树值最大结点）</li><li>目标结点的值 = childNode值</li><li>删除childNode(如果有且仅仅会有左子树，替补childNode位置)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉树查找的性能取决于该树的形状，其中比较值为目标结点所在的层数（深度），时间复杂度为：<em><strong>O（logn）</strong></em></p><p>在极度极端情况下，二叉树仅仅只有左树（或者右树），相当于遍历线性表，即顺序查找，时间复杂度为：<em><strong>O(n)</strong></em></p><p>因此我们更希望二叉树是一个平衡的树，即引出了平衡二叉树</p><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p><strong>平衡二叉树：</strong>属于一种二叉排序树，其中每一个结点的左子树和右子树的高度差最多为1</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>平衡因子BF(balance factor)：</strong>二叉树上结点左树的高度减去右树的高度（0，-1，1）</p><p><strong>最小不平衡树：</strong>距离插入结点最近的，<code>平衡因子绝对值大于1</code>的结点的子树</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>插入是否破坏平衡？<ul><li>若否 插入</li><li>若是 <ol><li>找出最小不平衡树</li><li>在不破坏二叉树特性的情况下，调整最小不平衡树中各节点的连接关系</li><li>进行旋转，成为新的平衡树</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象浅见</title>
      <link href="/2022/07/01/mian-xiang-dui-xiang-qian-jian/"/>
      <url>/2022/07/01/mian-xiang-dui-xiang-qian-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象（OO）"><a href="#面向对象（OO）" class="headerlink" title="面向对象（OO）"></a>面向对象（OO）</h1><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>类：封装对象属性和行为</li><li>方法：封装一定的业务逻辑功能</li><li>访问控制修饰符：封装具体的访问权限</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>作用：代码复用</p></li><li><p>超类：所有派生类共有的属性和行为</p><p>接口：部分派生类共有的属性和行为</p><p>派生类:派生类特有的属性和行为</p></li><li><p>单一继承、多接口实现，具有传递性</p></li></ul><ol><li>代码复用，通过extends来实现继承方法</li></ol><ul><li><p>派生类可以访问：派生类的+超类的   </p></li><li><p>超类不能访问派生类的</p><p>规定：构造派生类之前必须先构造超类</p></li></ul><ol start="2"><li><p>派生类构造中若不调用超类构造，则默认super()调超类无参构造</p></li><li><p>super：指当当前对象的超类对象</p></li></ol><p>super.成员变量名—————————访问超类的成员变量</p><p>super.方法名()——————————–调用超类的方法</p><p>super()——————————————调用超类的构造方法</p><p>补充</p><ul><li>super 和 this 不能同时调用方法</li><li>类属于引用数据类型</li><li>类里面不赋值，默认值即为数组的默认值（整型 0，引用 null，布尔false，浮点型0.0）</li><li>new n个  对象往往不会在for里面</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>意义：</p><ul><li><p>同一个对象被造型为不同的类型时，有不同的功能</p><p>—对象多态：我、你、水——————-所有对象都是多态的(明天再详细讨论)</p></li><li><p>同一类型的引用指向不同的对象时，有不同的实现</p><p>—行为多态：cut()，move()，getImage()……———所有抽象方法都是多态的</p></li></ul></li><li><p>向上造型：</p><ul><li>超类型的引用指向派生类的对象</li><li>能点出来什么，看引用的类型</li><li>能造型成为的类型有：超类+所实现的接口</li></ul></li><li><p>强转类型转换，成功的条件只有如下两种：</p><ul><li>引用所指向的对象，就是该类型</li><li>引用所指向的对象，实现了该接口或继承了该类</li></ul></li><li><p>强转时若不满足如上条件，则发生ClassCastException类型转换异常</p><p>建议：在强转之前先通过instanceof来判断引用指向的对象是否是该类型</p></li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>现实生活中有很多对象组成，基于对象抽出了类</p><ul><li><p>对象：软件中真是存在的单个个体，具有不同的属性</p><p>类：一类个体</p></li></ul><p>一般有几个对象，我们专门为此创建几个类   </p><ul><li><p>对象为具体，类为模子，一个类可以创建多个对象</p></li><li><p>类中包含</p><ul><li>对象的属性/特征——成员变量</li><li>对象的行为/动作/功能——方法（同一个类不能相同的方法签名）</li></ul></li><li><p>成员变量会默认初始值</p></li></ul><h3 id="this用法"><a href="#this用法" class="headerlink" title="this用法"></a>this用法</h3><ol><li><p>this：指代当前对象，哪个对象调用方法它指的就是哪个对象</p><p>​          只能用在方法中，方法中访问成员变量之前默认有个this.</p><p>this的用法：</p><ul><li><p>this.成员变量名————–访问成员变量</p><blockquote><p>当成员变量和局部变量同名时，若想访问成员变量则this不能省略，其它一般省略</p></blockquote></li><li><p>this.方法名()——————调用方法(一般不用，了解)</p></li><li><p>this()—————————-调用构造方法(一般不用，了解)</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token comment">//成员变量</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token comment">//构造方法</span>    <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token class-name">String</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>       <span class="token comment">//zs.name="zhangsan"</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>         <span class="token comment">//zs.age=25</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span> <span class="token comment">//zs.address="LF"</span>    <span class="token punctuation">}</span>    <span class="token comment">//实例方法</span>    <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"在学习..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁了，家住"</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//构造方法和this的演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//Student zs = new Student(); //编译错误，Student类没有无参构造</span>        <span class="token class-name">Student</span> zs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token string">"LF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> ls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token string">"JMS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        zs<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ls<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="方法和对象"><a href="#方法和对象" class="headerlink" title="方法和对象"></a>方法和对象</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法：构造函数、构造器、构建器—————-复用给成员变量初始化代码</p><ul><li><p>作用：给成员变量赋初始值</p></li><li><p>与类同名，没有返回值类型(连void都没有)</p></li><li><p>在创建(new)对象时被自动调用</p></li><li><p>若自己不写构造方法，则编译器默认提供一个无参构造方法，</p><p>若自己写了构造方法，则不再默认提供</p></li><li><p>构造方法可以重载</p></li></ul><p>补充</p><ul><li><p>行参：声明方法变量时</p><p>实参：调用方法时</p></li><li><p>方法签名：方法名+参数列表</p></li></ul><h3 id="方法的重载（overload）"><a href="#方法的重载（overload）" class="headerlink" title="方法的重载（overload）"></a>方法的重载（overload）</h3><ul><li>发生在同一类中，方法名相同，参数列表不同</li><li>编译器会根据参数列表的不同自动选择方法</li></ul><h3 id="方法的重写（override）"><a href="#方法的重写（override）" class="headerlink" title="方法的重写（override）"></a>方法的重写（override）</h3><ul><li><p>父子类中，方法名相同，参数列表相同（方法签名相同）</p></li><li><p>在运行时只走子类（new 的 对象）</p></li></ul><p>重写需遵循”两同两小一大”原则：</p><ul><li><p>两同：</p><ul><li>方法名相同</li><li>参数列表相同</li></ul></li><li><p>两小：</p><ul><li>派生类方法的返回值类型小于或等于超类方法的<ul><li>void和基本类型时，必须相等</li><li>引用类型时，可以小于或等于</li></ul></li><li>派生类方法抛出的异常小于或等于超类方法的————API时再说</li></ul></li><li><p>一大：</p><ul><li>派生类方法的访问权限大于或等于超类方法的</li></ul><p>补充: 静态方法不能被重写</p></li></ul><h3 id="方法的向上造型"><a href="#方法的向上造型" class="headerlink" title="方法的向上造型"></a>方法的向上造型</h3><ul><li>左边为超类容器，右边为派生类的参数</li><li>只能调用超类的数据、方法</li></ul><p>官方</p><ul><li>超类型的引用指向派生类的对象</li><li>能点出来什么，看引用的类型</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 做中餐 <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment">//1)我还是想做中餐-------------不需要重写</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//2)我想改做西餐---------------需要重写</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 做西餐 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3)我想在中餐之上加入西餐-------需要重写(先super中餐，再加入西餐)</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">+</span> 做西餐    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​abstract修饰，只有方法的定义，没有具体的实现(连{}都没有)</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract修饰，包含抽象方法的类必须是抽象类，不能被实例化</p><p>​    需要被继承，派生类：重写所有抽象方法</p><p>​封装共有的属性和行为—-代码复用     为所有派生类提供统一的类型—–向上造型</p><p>​    为所有派生类提供统一的入口(能点出来)，强制必须重写</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>一种引用数据类型，一种标准</p></li><li><p>由interf来定义（非修饰）</p></li><li><p>只包含常量和抽象方法</p></li><li><p>不能被new对象，不能实例化</p></li><li><p>接口是要被实现（implements）的，实现/派生类：必须重写所有抽象方法，必须加关键字public</p></li><li><p>一个类可以实现多个接口，用逗号分隔。若又继承又实现，先继承再实现</p></li><li><p>接口可以继承接口</p><p>补充</p><ul><li>类和类                继承</li><li>接口和接口        继承</li><li>类和接口            实现</li></ul></li></ul><h3 id="内外部类"><a href="#内外部类" class="headerlink" title="内外部类"></a>内外部类</h3><ol><li><p>成员内部类：应用率低</p><ul><li><p>类中套类，外面的称为外部类，里面的称为内部类</p></li><li><p>内部类通常只服务于外部类，对外不具备可见性</p></li><li><p>内部类对象通常在外部类中创建</p></li><li><p>内部类中可以直接访问外部类的成员(包括私有的)</p><p>内部类中有个隐式的引用指向了创建它的外部类对象—外部类名.this——API时会用</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClassDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Mama</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mama</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//Baby b = new Baby(); //编译错误，内部类对外不具备可见性</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Mama</span><span class="token punctuation">{</span> <span class="token comment">//外部类</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Baby</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Baby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Baby</span><span class="token punctuation">{</span> <span class="token comment">//内部类</span>        <span class="token keyword">void</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Mama</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Mama.this指代当前对象的外部类对象</span>            <span class="token comment">//System.out.println(this.name); //编译错误，this指代当前Baby对象</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>匿名内部类：重点—————–大大简化代码</p><ul><li>若想创建一个类(派生类)的对象，并且对象只被创建一次，可以做成匿名内部类</li><li>匿名内部类中不能修饰外面局部变量的值，因为在此处该变量会默认为final的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnonInnerClassDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//new Aoo(); //创建Aoo对象</span>        <span class="token comment">//new Aoo(){}; //创建Aoo的派生类的对象</span>        <span class="token comment">//1)创建了Aoo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o1</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Aoo</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//向上造型</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//1)创建了Aoo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o2</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Aoo</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        num <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>        <span class="token comment">//1)创建了Boo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o3</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Boo</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//重写Boo类的抽象方法</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"showshow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//num = 66; //编译错误，在此处会默认num为final的---API时会用</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        o3<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Boo</span><span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Aoo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="修饰关键词"><a href="#修饰关键词" class="headerlink" title="修饰关键词"></a>修饰关键词</h3><ol><li><p>package</p><ul><li>避免类冲突</li><li>同包中类不可以同名，不同包的类可以</li><li>类的全称包名.类名</li><li>建议所有包名小写</li></ul></li><li><p>impor</p><ul><li>同包中导入类，可以用<ul><li>不同包导入类，需要导入包</li><li>或者引用类的全称</li></ul></li></ul></li><li><p>访问控制符（导入包 不起作用）</p><ul><li><p>public              公开的</p></li><li><p>protected       本类 派生类 同包类</p></li><li><p>默认（不写） 本类 同包类  ——不建议</p></li><li><p>private            本类</p></li></ul></li><li><p>finall：最终的、不可更改的——单独利用率低</p><ul><li>修饰变量：变量不能被改变，为常量</li><li>修饰方法：方法不能被重写</li><li>修饰类：    类不能被继承</li></ul></li><li><p>static ：静态变量</p><ul><li>属于类</li></ul><p>​      成员变量分为两种</p><ul><li>实例变量：没有static修饰，属于对象的，存储在堆中，有几个对象就有几个实例变量</li></ul><p>​      需要通过引用打点来访问</p><ul><li><p>静态变量：</p><ul><li><p>由static修饰，属于类，存储在方法区中，只有一份</p></li><li><p>通过类名打点来访问</p></li><li><p>何时用：所有对象需要共享的数据（图片，音频，视频）</p></li></ul></li><li><p>静态方法：</p><ul><li>前两条同上</li><li>static将方法体隐式的this删去，不能直接访问实例成员（即静态方法只能访问静态成员）</li><li>何时用：方法操作和对象无关（不需要访问对象</li></ul></li><li><p>静态块</p><ul><li>由static修饰</li><li>属于类，在类加载的时候自动执行，一个类只加载一次，所以静态块也加载一次</li><li>何时用：初始化/加载静态资源（图片、音频、视频）</li></ul></li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span>    语句块<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li><p>static final(常量)</p><ul><li>必须声明同时初始化</li><li>由类名来访问</li><li>存储在常量池中，常量池存储在堆中</li><li>建议：常量名所有字母大写，多个单词用_分隔</li><li>编译器在编译时会将常量直接替换为具体的值，效率高</li></ul></li></ol><ul><li>何时用：数据永远不变且经常使用，例如状态</li></ul><h2 id="String类（举例）"><a href="#String类（举例）" class="headerlink" title="String类（举例）"></a>String类（举例）</h2><ul><li>java.lang.String 用final修饰，不能被继承（java.lang包可以直接引用）</li><li>采用Unicode编码，一个字符2字节</li><li>底层封装了字符的数组</li><li>字符串一旦创建，对象的内容永远无法改变，但字符串的引用可以重新赋值——不变对象</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li><p>java对字符串的优化措施：常量池（堆中）</p></li><li><p>推荐使用字面量/直接量来创建字符串，并且会缓存所有以字面量形式创建的字符串对象到常量池中，当使用相同字符量在创建字符串会重用对象以减少内存开销</p></li><li><p>用来存放字符串的地址 ，指向非常量池中的堆中</p></li><li><p>只能通过字面量相连才会复用，不用使用引用的对象名</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 以上创建了几个对象</span><span class="token comment">/** * 答 2个 * 第一个： 字面量“hello” * 创建一个字面量对象表示“hello”，并将其存入常量池* 第二个：* new String() 时会再创建一个字符串对象， */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>对象名.length（）： 获取字符串长度，return int</p></li><li><p>对象名.trim（）： 去除当前字符串两边的空白字符，return一个新对象</p></li><li><p>对象名.toUpperCase（）：将当前符号中的英文转换为全大写</p><p>对象名.toLowerCase（）：将当前符号中的英文转换为全小写</p><p>全部return String</p></li><li><p>对象名.startsWith（”sth”）：判断字符串是否以”sth“ 开头，return boolea类型</p><p>对象名.endsWith（”sth”）：判断字符串是否以” sth “ 结尾，return boolea类型</p><p>区分大小写</p></li><li><p>对象名.charAt(int index) : 返回下标处的字符，return char</p></li><li><ol><li><p>对象名.indexOf(String str ) :检索str在String开始的下标，return int</p></li><li><p>对象名.indexOf(String str, int fromIndex ) :检索str在String从下标”fromIndex“以后的下标，return int。其中return的值为差值</p></li><li><p>对象名.lastIndexOf(String str): 检索str在String最后一次的下标，return int</p></li></ol><p>若找不到目标字符串，返回-1</p></li><li><p>对象名.substring(int a,int b)  ：截取下标 a到 b 之间的字符串  return String</p><p>对象名.substring(int a)           ：截取从下标a一直到末尾， return String</p></li><li><p>String.valueOf(a):将基本数据类型a所代表的值转换为String，return String</p></li></ul><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ul><li><p>由于String是不变对象，每次修改内容要创建新对象，因此String不适合做频繁修改操作，为了解决这个问题，java提供了StringBuilder类。</p></li><li><p>StringBuilder是专门用于修改字符串的一个API，内部维护一个可变的char数组，修改都是在这个数组上进行的，修改速度、性能优秀，并且提供了修改字符串的常见的方法：增、删、改、插</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//String不适合频繁修改内容</span><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s <span class="token operator">=</span> s<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用StringBuilder可以提高修改字符串的性能</span><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>StringBuilder常用方法：</p><ul><li>append()：追加内容</li><li>replace()：替换部分内容</li><li>delete()：删除部分内容</li><li>insert()：插入内容</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"好好学习java"</span><span class="token punctuation">;</span><span class="token comment">//复制str中的内容到builder中-----好好学习java</span><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append():追加内容</span>builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"，为了找个好工作!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//好好学习java，为了找个好工作!</span><span class="token comment">//replace():替换部分内容</span>builder<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">"就是为了改变世界"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//替换下标9到15的</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//好好学习java，就是为了改变世界!</span><span class="token comment">//delete():删除部分内容</span>builder<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除下标0到7的</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//，就是为了改变世界!</span><span class="token comment">//insert():插入操作</span>builder<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"活着"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从下标0的位置插入</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//活着，就是为了改变世界!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(概述、应用层、运输层)</title>
      <link href="/2022/07/01/ji-suan-ji-wang-luo-zi-ding-er-xia-de-fang-fa/"/>
      <url>/2022/07/01/ji-suan-ji-wang-luo-zi-ding-er-xia-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-自顶而下的方法"><a href="#计算机网络-自顶而下的方法" class="headerlink" title="计算机网络 自顶而下的方法"></a>计算机网络 自顶而下的方法</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><ul><li><p>应用层 ：是对应用到应用的抽象</p></li><li><p>运输层 ：提供socket 到 socket的抽象接口</p></li><li><p>网络层 ：提供主机到主机的抽象接口</p></li><li><p>链路层 ：线缆的抽象接口</p></li><li><p>物理层 ：发生在物理线路</p></li></ul><h3 id="1-第五层——应用层-application-layer"><a href="#1-第五层——应用层-application-layer" class="headerlink" title="1 第五层——应用层(application layer)"></a>1 第五层——应用层(application layer)</h3><ul><li><strong>应用层(application layer)：</strong>是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。</li><li>在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。</li></ul><h3 id="2-第四层——运输层-transport-layer"><a href="#2-第四层——运输层-transport-layer" class="headerlink" title="2. 第四层——运输层(transport layer)"></a>2. 第四层——运输层(transport layer)</h3><ul><li><strong>运输层(transport layer)：</strong>负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</li><li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li><li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li><li><strong>运输层主要使用以下两种协议：</strong><br><strong>(1) 传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br><strong>(2) 用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li></ul><h3 id="3-第三层——网络层-network-layer"><a href="#3-第三层——网络层-network-layer" class="headerlink" title="3. 第三层——网络层(network layer)"></a>3. 第三层——网络层(network layer)</h3><ul><li><strong>网络层(network layer)主要包括以下两个任务：</strong></li><li><strong>(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</strong></li><li><strong>(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</strong></li><li><strong>协议：IP,ICMP,IGMP,ARP,RARP</strong></li></ul><h3 id="4-第二层——数据链路层-data-link-layer"><a href="#4-第二层——数据链路层-data-link-layer" class="headerlink" title="4. 第二层——数据链路层(data link layer)"></a>4. 第二层——数据链路层(data link layer)</h3><ul><li><strong>数据链路层(data link layer)：</strong>常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。</li><li>每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</li><li>注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。<br>(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。<br>(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</li></ul><h3 id="5-第一层——物理层-physical-layer"><a href="#5-第一层——物理层-physical-layer" class="headerlink" title="5. 第一层——物理层(physical layer)"></a>5. 第一层——物理层(physical layer)</h3><ul><li><strong>物理层(physical layer)：</strong>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</li></ul><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>  <img src="https://user-images.githubusercontent.com/105496252/176896116-5d70b5a9-4b4a-42fd-a990-39e394104e5c.jpg"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>RTT（Round Trip Time）：往返时延，也就是<strong>数据包从发出去到收到对应 ACK 的时间。</strong>RTT 是针对连接的，每一个连接都有各自独立的 RTT。</p></li><li><p>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</p></li><li><p>TCP超时重传： 如果发送方认为发生了丢包现象，就重发这些数据包，接收方每收到一个包，就向发送方返回一个 <strong>ACK</strong>，表示自己已经收到了这段数据，反过来，如果发送方一段时间内没有收到 ACK，就知道<strong>很可能</strong>是数据包丢失了，紧接着就重发该数据包，直到收到 ACK 为止。 </p></li><li><p>传播时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> </p></li><li><p>传输时间： <em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em></p></li></ul><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="1英特网"><a href="#1英特网" class="headerlink" title="1英特网"></a>1英特网</h3><h3 id="2网络边缘"><a href="#2网络边缘" class="headerlink" title="2网络边缘"></a>2网络边缘</h3><ul><li><p>住宅接入：DSL、电缆、FTTH、卫星、拨号接入（拨号调制解调器）、以太网、WiFi等<br>公司接入：以太网、WiFi等<br>广域无线接入：3G、4G、LTE等 </p></li><li><p>拨号调制解调器：最高速度为 56 Kbps，专用的<br>HFC：高达 42.8 Mbps 下行速率和高达 30.7 Mbps 的上行速率，共享的<br>DSL：最高 24 Mbps 下行速率和最高 2.5 Mbps 上行速率，专用的<br>FTTH: 最高 4Mbps 上行，100Mbps 下行速率，专用的</p></li></ul><h3 id="3交换机链路系统"><a href="#3交换机链路系统" class="headerlink" title="3交换机链路系统"></a>3交换机链路系统</h3><ul><li>电路交换网络预留了宽带，传统的电路交换分离出单个信号需要多个滤波器</li><li>谷歌使用专门网络避开高层ISP，获得更好的用户体验和公司的流量运输费用</li></ul><h3 id="4数据传输"><a href="#4数据传输" class="headerlink" title="4数据传输"></a>4数据传输</h3><ul><li>处理时延，排队时延，传输时延，传播时延。<br> 除了排队时延之外都是固定的 </li><li>传送文件的吞吐量一般为途径链路的最小速度</li><li>流量强度=最大速度/最小速度</li><li>数据包传输具有随机性</li></ul><h4 id="传播时延和传输时延"><a href="#传播时延和传输时延" class="headerlink" title="传播时延和传输时延"></a>传播时延和传输时延</h4><p>假设AB间速率为Rbps，相隔M米，链路的传播速度s m/s，发送L比特长度文件</p><ul><li>传播时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> </li><li>传输时间： <em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em> </li><li>端到端的时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> +<em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em>   （去除其他时延）</li></ul><h3 id="5协议层次和模型"><a href="#5协议层次和模型" class="headerlink" title="5协议层次和模型"></a>5协议层次和模型</h3><h4 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h4><p>5个</p><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p>路由器</p><p> 路由器处理网络层、链路层、物理层，链路层（现代的路由器有可能会担当防火墙或缓存，因此可能会处理运输层）。交换机处理链路层。主机处理所有五个层次。 </p><h3 id="6面对的网络攻击"><a href="#6面对的网络攻击" class="headerlink" title="6面对的网络攻击"></a>6面对的网络攻击</h3><p> 病毒是需要用户交互来感染用户设备的恶意软件；蠕虫无需用户交互。                  </p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="万维网应用"><a href="#万维网应用" class="headerlink" title="万维网应用"></a>万维网应用</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>拉的作用</p><h3 id="电子邮件应用"><a href="#电子邮件应用" class="headerlink" title="电子邮件应用"></a>电子邮件应用</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>推的作用</p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>负责邮件下载——删除——转移存储</p><h3 id="文件传送"><a href="#文件传送" class="headerlink" title="文件传送"></a>文件传送</h3><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>​       FTP使用两个并行的TCP连接，一个用于发送控制信息(比如传输文件的请求)，另一个用于实际传输文件。因为控制信息不是通过发送文件的同一连接发送的，所以说FTP在带外发送控制信息 </p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p> DNS就是把域名解析为IP地址，提供我们上网，我们能够上网最终是找到IP地址。 </p><p>修改DNS的好处</p><ol><li>适当提高上网速度；</li><li>更换DNS可以访问某些因为域名解析存在问题而不能访问的网站；</li><li>可以屏蔽运营商的广告，还可以帮助您避免被钓鱼的危险；</li></ol><p>修改DNS带来的副作用</p><ol><li>无法访问页面或者访问的页面不是你想要的页面；</li><li>访问速度没有你从运营商处获得的DNS访问分速度快，延时比较大；</li><li>·受到DNS劫持，插入广告和被钓鱼网站攻击；</li></ol><p>注释：一个网站可有有多个域名，对应不同IP地址</p><h4 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h4><p>我为人人，人人为我</p><p>例子 : 迅雷BT种子</p><h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>多路复用：家里某人收集众人邮件给邮递员</p><p>分解：邮递员把文件包给家中某人，其将包裹分解分发给家人</p><p>纠错检验功能：TCP相对比较复杂，UDP比较简单</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>拥有拥塞控制、顺序控制、超时重传等等功能，因为套字相对于UDP比较多，速度相对较慢。</p><p>适合于大文件、要求文件传输完整性的传输。</p><p>需要两个套接字</p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>就是两个通信实体在互相发送数据之前首先交换控制数据包。SMTP在应用层使用握手协议，而HTTP没有。 </p><ul><li><p>三次握手，第四次携带请求下载的信息</p></li><li><p>非连续TCP </p><p>​       重新三次握手</p></li><li><p>连续TCP</p><p>​        后续 第二次请求即以后仅仅需要发送请求（1），得到回复信息（2），不需要两次握手</p><ul><li>串联  重新考虑传播消耗</li><li>并联  均分速率，避开传播消耗</li></ul></li></ul><h4 id="自动重传请求（ARQ）"><a href="#自动重传请求（ARQ）" class="headerlink" title="自动重传请求（ARQ）"></a>自动重传请求（ARQ）</h4><p>需要协同的协议</p><ul><li>差错检测 额外的比特在报文中</li><li>接收方反馈</li><li>重传</li></ul><p>滑动窗口传输协议（GBN）</p><ul><li>多分组以窗口传送</li><li>接收方接收到受损分组主动丢失该窗口的N个分组（减少接收方缓存）</li><li>回复ACK1或0（1、0交替）为确认，NAK为未收到；同时也存在ACK答复报文的丢失</li><li>发送方式 0123—1234——2345-—3456——error2——2345</li></ul><p>选择重传（SR）</p><ul><li>失去ack序号的组等待重传，其他正确的窗口内的组在接收方等待缓存，待ACK全部达到，进行性下一步、</li><li>协议长度过长将无法工作，必须小于等于序号空间的一半</li></ul><p>拥塞控制</p><ul><li><p>慢启动</p><p>发送速率cwnd为MSS/RTT，以后每过一个RTT成指数增长</p></li><li><p>拥塞避免</p><ul><li><p>当无法再增加一倍时，在一个RTT只增加一个MSS</p><p>即假设cwnd=10mss，每收到一个ack增加1/10个MSS</p></li></ul></li><li><p>快速回复</p><p>速度当收到3个冗余ack时，变为（一半+3个MSS）</p></li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>对UDP，事务可以在一次往返时间(RTT)中完成——客户端将事务请求发送到UDP套接字，服务器将应答发送回客户端的UDP套接字。对于TCP，至少需要两个RTTs—一个用于建立TCP连接，另一个用于客户端发送请求以及服务器发送回复。（鉴于TCP是面向连接，传输前要进行三次握手而UDP不需建立连接 没有拥塞机制</p><p>​      仅仅需要一个套接字</p><p>​     从应用层的来的数据装修（近似于和IP打交道），仅仅4个字段，8字节：</p><ul><li>多路分解/复用字段（源端口号/目的端口号）</li><li>长度</li><li>校验和（运输到目的地后校验）</li></ul><p>部分UDP可以在运输层的使用UDP，并在应用层使用特定协议保持数据可靠性（谷歌浏览器的quic，处于应用层）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>低延迟</li><li>报文段字节较少，仅仅8字节</li><li>无连接状态，不跟踪数据传输信息，可以支持更多活跃用户</li></ul><h4 id="纠错检验（端到端原则）"><a href="#纠错检验（端到端原则）" class="headerlink" title="纠错检验（端到端原则）"></a>纠错检验（端到端原则）</h4><p>四个16比特的字节之和为1111111111111111（16个1）</p><p>如果溢出则回卷，出现个别0</p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础语法</title>
      <link href="/2022/07/01/java-ji-chu-yu-fa/"/>
      <url>/2022/07/01/java-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>​     数据类型                    关键字      包装类型   内存占用取值范围</p><ul><li>字节型                       byte            Byte        1个字节-128~127</li><li>短整型                       short          Short       2个字节-32768~32767</li><li>整型                       int              Integer    4个字节-2^31~2^31-1</li><li>长整型                       long(L)         Long      8个字节-2^63~2^63-1</li><li>单精度浮点数           float(F)         Float      4个字节38位</li><li>双精度浮点数           double(D)    Double  8个字节308位</li><li>字符型                       char            Character  2个字节0~65535</li><li>布尔类型                   boolean      Boolean 1个字节true,false</li></ul><p>※数据范围和字节数不一定相关。如float范围比long大，但字节数小。</p><p>※浮点数是一个近似值：double s =4.0-3.6; //打印s为：0.3999999999</p><p>  其本质是<strong>科学计数法</strong>,</p><ul><li>第一位符号位,表示正负,0为负,1为正数</li><li>中间8(11)位即阶码,用以存贮指数位置的值</li><li>最后23(52)位即尾数,用以精确表示数字的值,各自精确小数点后6-7(15-16)</li></ul><p><img src="https://user-images.githubusercontent.com/105496252/176885809-33432ccf-cce0-4529-9fe2-e21b706e9df5.png" alt="浮点数据类型比特位分配"></p><p>※Infinity：无穷大，除以0可得，5.0/0</p><p>※NAN：not a number， 0.0/0</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>只能包含                                <font color="red"> 字母 数字 _ $ </font></p><p>杜绝</p><ul><li>单个字母</li><li>中文（部分框架不允许）</li><li>中文拼音</li><li>不使用关键字</li></ul><p>建议</p><ul><li>小驼峰输入法 （第一个首字母不大写）   myScore， myJavaScore</li><li>大驼峰输入法（所有首字母都大写）</li><li>英文</li></ul><h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">如果参与运算的类型不一样，则自动转化为相同类型<span class="token keyword">char</span>\<span class="token keyword">byte</span>\<span class="token keyword">short</span><span class="token operator">--</span><span class="token keyword">int</span><span class="token operator">--</span><span class="token keyword">long</span><span class="token operator">--</span><span class="token keyword">float</span><span class="token operator">-</span>doubleint<span class="token operator">*</span><span class="token keyword">long</span><span class="token operator">=</span><span class="token keyword">long</span><span class="token operator">*</span><span class="token keyword">long</span>    <span class="token keyword">byte</span>、<span class="token keyword">char</span>、<span class="token keyword">short</span> 在参与运算时，一律为<span class="token keyword">int</span>计算结果会溢出溢出不会报错，自动重新填<span class="token punctuation">(</span>最大值加<span class="token number">1</span>为最小值<span class="token punctuation">)</span> <span class="token keyword">byte</span> b1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b2 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//4</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//52，2加上'2'的码50</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token operator">+</span><span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//100，'2'的码50，加上'2'的码50</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量取值最大数"><a href="#变量取值最大数" class="headerlink" title="变量取值最大数"></a>变量取值最大数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="强转数据类型"><a href="#强转数据类型" class="headerlink" title="强转数据类型"></a>强转数据类型</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span><span class="token keyword">byte</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token comment">//注意溢出误差、精度丢失</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="两点原则"><a href="#两点原则" class="headerlink" title="两点原则"></a>两点原则</h4><ul><li>整数直接量可以直接赋值给byte,short,char，但不能超出范围</li><li>byte,short,char型数据参与运算时，系统会将其自动转换为int再运算</li></ul><h4 id="转义符（char类型）"><a href="#转义符（char类型）" class="headerlink" title="转义符（char类型）"></a>转义符（char类型）</h4><p>特殊符号需要通过\来转义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token char">'女'</span><span class="token punctuation">;</span>  <span class="token comment">//字符女</span><span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token char">'f'</span><span class="token punctuation">;</span>  <span class="token comment">//字符f</span><span class="token keyword">char</span> c3 <span class="token operator">=</span> <span class="token char">'6'</span><span class="token punctuation">;</span>  <span class="token comment">//字符6</span><span class="token keyword">char</span> c4 <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>  <span class="token comment">//字符*</span><span class="token comment">//char c5 = 女; //编译错误，字符型直接量必须放在单引号中</span><span class="token comment">//char c6 = ''; //编译错误，单引号中必须有字符</span><span class="token comment">//char c7 = '25'; //编译错误，只能有一个字符</span><span class="token keyword">char</span> c8 <span class="token operator">=</span> <span class="token char">'\\'</span><span class="token punctuation">;</span> <span class="token comment">//\为特殊符号，需要通过\来转义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c8<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换变量（三个杯子原理）"><a href="#交换变量（三个杯子原理）" class="headerlink" title="交换变量（三个杯子原理）"></a>交换变量（三个杯子原理）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>b <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//首尾相连</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">if</span>语句                           <span class="token keyword">switch</span>语句<span class="token keyword">if</span><span class="token punctuation">(</span>关系表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token function">siwtch</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>语句体<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>关系表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">case</span> 常量值<span class="token number">1</span><span class="token operator">:</span> 语句体<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>语句体<span class="token punctuation">;</span>                        <span class="token keyword">case</span> 常量值<span class="token number">2</span><span class="token operator">:</span> 语句体<span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                           …语句体<span class="token punctuation">;</span>                        <span class="token keyword">default</span><span class="token operator">:</span>语句体n<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>                               <span class="token punctuation">}</span>          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>byte、short、int、char、String、枚举</p><p>在条件选择后以此为开始，向下贯穿。JAVA</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">普通<span class="token keyword">for</span>循环：    <span class="token keyword">for</span><span class="token punctuation">(</span>初始表达式<span class="token punctuation">;</span>布尔表达式<span class="token punctuation">;</span>步进表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>     循环体；<span class="token punctuation">}</span><span class="token keyword">while</span>循环：    初始表达式<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>条件判断<span class="token punctuation">)</span><span class="token punctuation">{</span>     循环体<span class="token punctuation">;</span>步进语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">do</span><span class="token operator">-</span><span class="token keyword">while</span>循环：初始表达式<span class="token punctuation">;</span>   <span class="token keyword">do</span><span class="token punctuation">{</span>     循环体<span class="token punctuation">;</span>      步进语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>条件判断<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>break：跳出循环———–可以用在switch和循环中</li><li>continue：跳过循环体中剩余语句而进入下一次循环——只能用在循环中</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><p>System.arraycopy(a,1,b,0,4);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//0,0,0,0,0,0</span><span class="token comment">//a:源数组</span><span class="token comment">//1:源数组的起始下标</span><span class="token comment">//b:目标数组</span><span class="token comment">//0:目标数组的起始下标</span><span class="token comment">//4:要复制的元素个数</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//灵活性好</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>int[] b = Arrays.copyOf(a,6);<br>a = Arrays.copyOf(a,a.length+1); //数组的扩容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//a:源数组</span><span class="token comment">//b:目标数组</span><span class="token comment">//6:目标数组的长度</span><span class="token comment">//----若目标数组的长度&gt;源数组长度，则在末尾补默认值</span><span class="token comment">//----若目标数组的长度&lt;源数组长度，则将末尾的截掉</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//数组的扩容</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//数组的扩容(创建了一个更大的新的数组，并将数据复制进去了)</span>a <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p>Arrays.sort(arr);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对arr进行升序排列</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"倒序输出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只是倒着显示，但数组中数据没有改变</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h3><ul><li>数组超过长度异常</li><li>空指针异常（NullPointerException）：栈上的变量为赋值null,指针被消除，与堆的联系中断</li></ul><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="定义五要素"><a href="#定义五要素" class="headerlink" title="定义五要素"></a>定义五要素</h3><ul><li><p>返回值可有（特定数据类型 int 、boolean、数组等等） 可无（void）</p></li><li><p>修饰词</p></li><li><p>方法名</p><p>见名字知意思</p></li><li><p>参数列表</p><ul><li>有参 传进去的为指针</li></ul><p>参数里面的数值表示引用，调用引用数据类型的地址和基本数据类型的地址</p><p>基本数据类型的值不能改变（改变为另一个声明，使用需要return）</p><p>应用数据类型不能改变对象，可以改变对象的值，数组的值</p></li><li><p>方法体</p></li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>方法：函数、过程</p><ul><li><p>封装一段特定的业务逻辑功能</p></li><li><p>尽可能独立，一个方法只干一件事</p></li><li><p>方法可以被反复调用多次</p></li><li><p>可以减少代码重复，有利于代码维护</p></li><li><p>何时用：假设有一个功能，在很多地方都得使用，就将功能封装到一个方法中</p></li><li><p>行参：声明方法变量时</p><p>实参：调用方法时</p></li></ul></li><li><p>方法的定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//无参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫WKJ，今年38岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//有参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//形参</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年38岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//有参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//形参</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//无参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//若方法有返回值，则在方法中必须出现return关键字</span>    <span class="token comment">//并且return后的数的类型必须与返回值类型匹配</span>    <span class="token comment">//return "abc"; //编译错误</span>    <span class="token keyword">return</span> <span class="token number">8.88</span><span class="token punctuation">;</span> <span class="token comment">//1)结束方法的执行  2)返回结果给调用方</span><span class="token punctuation">}</span><span class="token comment">//有参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span><span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> num1<span class="token operator">+</span>num2<span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span> <span class="token comment">//返回的是num里面的那个数</span>    <span class="token comment">//return num1+num2; //返回的是num1与num2的和</span><span class="token punctuation">}</span><span class="token comment">//无参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法的调用：</p><ul><li><p>无返回值：方法名(有参传参);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用say()方法</span>        <span class="token comment">//sayHi(); //编译错误，有参则必须传参</span>        <span class="token comment">//sayHi(250); //编译错误，参数类型必须匹配</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="zhangsan"  //实参</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="lisi"          //实参</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="wangwu"      //实参</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参 String name="zhangsan",int age=25</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有返回值：数据类型  变量  =  方法名(有参传参);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//方法的演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//getNum()的值就是return后的那个数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//8.88，模拟对返回值的后续操作</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//plus(5,6)的值就是return后的那个数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11，模拟对返回值的后续操作</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传递的是m和n里面的数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11，模拟对返回值的后续操作</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"长度为:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10，模拟对返回值的后续操作</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>d<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//模拟对返回值的后续操作</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>return：</p><ul><li>return 值;  //1) 结束方法的执行  2) 返回结果给调用方</li><li>return;       //1) 结束方法的执行</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_查找</title>
      <link href="/2022/07/01/xian-xing-suo-yin-cha-zhao/"/>
      <url>/2022/07/01/xian-xing-suo-yin-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><h2 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h2><p>查找表按照操作方式有两大种</p><ul><li>静态查找表:只做查找操作</li><li>动态查找表:查找过程中同时进行增删元素</li></ul><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p>又称为顺序查找,遍历元素进行查找,</p><ul><li>算法时间复杂度为<em><strong>O(n)</strong></em></li></ul><h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><p>通过分隔点的不同,引入三种算法</p><h4 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找(二分查找)"></a>折半查找(二分查找)</h4><ul><li><p>前提 : 关键码有序(通常从小到大)</p><p>​           线性表必须使用顺序存储</p><p>​   更适合静态查找表(动态需要在增删后维护) </p></li><li><p>方法 :  类似于二叉树查找,取中间值比较大小,进入下一区域</p><p>​           进一步在下一区域 ,取中值比较大小….循环 </p></li><li><p>时间复杂度 :  <em><strong>O(logn)</strong></em></p></li></ul><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul><li><p><strong>前提、时间复杂度</strong>近似于折半查</p></li><li><p>用法 : 类似于查找新华字典,会提前寻找一个大致字母的区域</p><p>​ 根据查找的关键词字key与查找表中的最大值与最小值的比较后查找</p><p><code>Mid = Begin + ( (End - Begin) / (A[End] - A[Begin]) ) * (X - A[Begin])</code></p><ul><li>Mid：计算得出的元素的位置；</li><li>End：搜索区域内最后一个元素所在的位置；</li><li>Begin：搜索区域内第一个元素所在的位置；</li><li>X：要查找的目标元素；</li><li>A[]：表示整个待搜索序列</li></ul></li><li><p>适用: 表较长,关键字分布比较均匀</p></li></ul><h4 id="斐波那切查找"><a href="#斐波那切查找" class="headerlink" title="斐波那切查找"></a>斐波那切查找</h4><p>算法核心</p><ul><li>斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</li><li>优势 :   <ol><li>查找以加法进行运算(插值为四则运算,折半为加法和除法)</li><li>时间复杂度虽然为 <em><strong>O(logn)</strong></em>,但平均性能大于折半(目标为1时为极端情况,会劣于前者)</li></ol></li></ul><h3 id="线性索引查找-1"><a href="#线性索引查找-1" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>针对海量数据,关键码也不一定按照有序排列,不能遍历或者半遍历元素，就引入了索引</p><ul><li>索引即为将一个关键字和它对应的记录关联的过程</li><li>分为<strong>线性</strong>、<strong>树形</strong>、<strong>多级</strong>索引，这里主要介绍线性索引</li></ul><p><strong>线性索引</strong>即为将索引项集合组织为线性结构，也陈之为索引表,重点介绍以下几种</p><ul><li>稠密索引</li><li>分块索引</li><li>倒排索引</li></ul><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p>数据的每一个记录对应一个索引项</p><p><img src="https://user-images.githubusercontent.com/105496252/176885763-b4d74a30-ec4a-47c6-9918-79d6b3b49035.jpg" alt="稠密索引"></p><ul><li><p>优点: 数据项是无序的,索引项是有序的</p><p>​          可以对索引项进行有序查找</p></li><li><p>缺点 : 每一次查询需要在磁盘中读取更多内存,数据庞大时(上亿级别)</p><p>​          查询性能反而下降</p></li></ul><h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p>类似如图书馆藏书管理体系.将数据集分成了若干块,各自建立索引项,指向各自的块内元素</p><ul><li><p>块内无序 : 理论上可以有序更好,但是需要花费不成正比的维护成本,故不做要求</p></li><li><p>快间有序 : 第N块所有元素的关键字永远<strong>全部</strong>小于第N+1块里的每个元素</p></li></ul><img src="https://user-images.githubusercontent.com/105496252/176885792-12a3eec1-28a8-4a32-9f6d-736ead78305e.png" alt="分块索引" style="zoom: 50%;"><p>最大关键码 : 每个块中关键字最大的元素关键码值</p><p>块长 : 每个块内元素的个数</p><p>块首指针 : 指向块首元素</p><ul><li>方法 : 在块间使用有序查找,在块内使用顺序查找(遍历)</li><li>时间复杂度 : ASL<sub>w</sub>=√n + 1  (介于顺序查找和折半查找之间)</li></ul><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>通用结构</p><ul><li>次关键码 : 类似于搜索引擎中的关键字</li><li>记录号表 : 类似于搜索引擎中对应出的整体文章标号</li></ul><p>其中记录号表存储的具有相同次关键词的所有的记录的记录号(可以是指向记录的指针或者是该记录的关键字)</p><ul><li>优点 : 查找非常快</li><li>缺点 : 维护比较困难,每一个记录号都将对应好几个文章,插入删除需要额外的处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2022/06/29/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2022/06/29/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
