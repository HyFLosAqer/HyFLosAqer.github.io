<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetCode8字符串转换整数</title>
      <link href="/2022/08/03/leetcode8-zi-fu-chuan-zhuan-huan-zheng-shu/"/>
      <url>/2022/08/03/leetcode8-zi-fu-chuan-zhuan-huan-zheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="一段胡乱拼凑却能跑还跑得不错的代码"><a href="#一段胡乱拼凑却能跑还跑得不错的代码" class="headerlink" title="一段胡乱拼凑却能跑还跑得不错的代码"></a>一段胡乱拼凑却能跑还跑得不错的代码</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://user-images.githubusercontent.com/105496252/182507063-ec85d09a-8800-4a4d-bfd5-b22c8667aec8.png" alt="leetCode第八题"></p><h2 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h2><p>输入一个字符串,逐个读取字符</p><ul><li>如果开头首先n个空格,删去连续的空格（如果n == 0 ，直接下一步）</li><li>空格后的第一位可以读取 <code>数字 </code>、<code> +</code> 、<code> -</code>  <ul><li><code>+</code>不处理,读下一个</li><li><code>-</code>将返回值int为负数,读下一个</li><li><code>数字</code>将转换为int一位,读下一个</li><li>如果读取到其他字母 ，直接reture 0</li></ul></li><li>之后只能读取<code>数字</code>,否则返回已经读取到的int<ul><li>新数字append到最后的个位数</li></ul></li></ul><blockquote><p>不能溢出</p></blockquote><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NO8</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NINE_VALUE_MAX_INTEGER <span class="token operator">=</span> <span class="token number">214748364</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TEN_VALUE <span class="token operator">=</span> <span class="token number">1000000000</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ASCII_ZERO <span class="token operator">=</span> <span class="token number">47</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ASCII_NINE <span class="token operator">=</span> <span class="token number">58</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 去除空格</span>    <span class="token comment">//    int j = 0;</span>    <span class="token comment">//    for ( j = 0; j &lt; s.length(); j++) {</span>    <span class="token comment">//      if (s.charAt(j) &gt; ASCII_ZERO &amp;&amp; s.charAt(j) &lt; ASCII_NINE) break;</span>    <span class="token comment">//      if (s.charAt(j) == '+' || s.charAt(j) == '-') break;</span>    <span class="token comment">//      if (s.charAt(j) == ' ') continue;</span>    <span class="token comment">//      if (s.charAt(j) != ' ') return 0;</span>    <span class="token comment">//      if (j == s.length() - 1) return 0;</span>    <span class="token comment">//    }</span>    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'-'</span> <span class="token operator">&amp;&amp;</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">&amp;&amp;</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&gt;</span> ASCII_ZERO <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ASCII_NINE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">+</span> r <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> NINE_VALUE_MAX_INTEGER <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> TEN_VALUE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> ASCII_ZERO <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ASCII_NINE<span class="token punctuation">)</span>            <span class="token keyword">return</span> flag <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> TEN_VALUE <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> ASCII_ZERO <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ASCII_NINE<span class="token punctuation">)</span>            <span class="token keyword">return</span> flag <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> r <span class="token operator">*</span> flag<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> NINE_VALUE_MAX_INTEGER <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">8</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> NINE_VALUE_MAX_INTEGER <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">7</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> r <span class="token operator">*</span> flag<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://user-images.githubusercontent.com/105496252/182507038-4df3d6f6-55e9-4c90-8f69-8b9bf9bdd827.jpg" alt="提交结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在写代码的过程中源代码一直觉得自己写了一手垃圾成山的代码<br>数次想过推翻重来<br>醒着头皮跑下来，时间效率竟然让我非常惊喜</p><ul><li>第一步一直在想如何去字符的开头空格，想遍历然后读到非空格之后substring，逻辑一直难以完善<ul><li>实际上最好的方法是设置一个int的指针或者说哨兵，读取更加方便；但是自己一开始没有使用，写了一班了就想一路黑下去，不想改了</li><li>最后用了string.trim()，我看了源代码，它是首位都会判断遍历去空格（恰好符合要求），其实额外增加了复杂度，最好还是仅仅自己写出仅仅去开头空格的</li></ul></li><li>后面是处理数字的拼接，实际上即将到达溢出的时候使用了几个判断，个人觉得还是比较愚蠢的</li></ul><p><strong>本题就是属于自己头铁就按照一开始的思路写下去然后发现时间效率还不错的凑巧</strong></p>]]></content>
      
      
      <categories>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收</title>
      <link href="/2022/07/19/gc-hui-shou/"/>
      <url>/2022/07/19/gc-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="GC回收"><a href="#GC回收" class="headerlink" title="GC回收"></a>GC回收</h1><p> 基于正在使用的对象进行遍历，对存活的对象进行标记，其未标记的对象可以认为是垃圾对象，然后基于特定的算法进行回收，这个过程称之为GC（Garbage Collection）。</p><p>通过以下几个方面进行实现</p><ul><li>GC判断策略（例如引用计数、对象可达性分析）</li><li>GC收集算法（标记-清除、标记-清除-整理、标记-复制-清楚）</li><li>GC收集器（例如Serial,Parallel,CMS,G1）</li></ul><h2 id="GC种类"><a href="#GC种类" class="headerlink" title="GC种类"></a>GC种类</h2><h3 id="手动GC"><a href="#手动GC" class="headerlink" title="手动GC"></a>手动GC</h3><p>显示地进行内存分配（allocate）和内存释放（free）。如果忘记释放，该内存就不能再次被使用，称之为内存泄漏（memory leak）</p><p>手动需要C语言进行，java不能够手动操作内存</p><h3 id="自动GC"><a href="#自动GC" class="headerlink" title="自动GC"></a>自动GC</h3><p>一般实在JVM系统内存不足时，有JVM系统启动GC对象，自动对内存进行垃圾回收</p><p>如果GC的速度小于对象分配内存的时候，也会造成内存溢出</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p><img src="https://user-images.githubusercontent.com/105496252/179641716-183d29e4-8022-4265-8073-a5d15a8c441e.jpg" alt="引用计数法"></p><ul><li><p>绿色圆圈是内存中的根对象，表示程序正在使用的对象</p></li><li><p>蓝色圆圈是内存中的活动对象，其中的数字表示其引用计数</p></li><li><p>灰色圆圈是内存中没有活动对象引用的对象，表示非活动对象（垃圾对象）</p><p><img src="https://user-images.githubusercontent.com/105496252/179641724-411f2697-008f-4eee-8e26-7e2ea7fda643.jpg" alt="循环引用"></p></li></ul><p>存在一个设计缺陷即<strong>循环引用</strong>，如上图的红色即为垃圾，有计数 无法被回收，引发内存泄漏</p><p>通过<strong>弱引用</strong>、<strong>软引用</strong>或者其他算法来排除</p><blockquote><p>弱引用weak reference：WeakReference的一个特点是它何时被回收是不可确定的, 因为这是由GC运行的不确定性所确定的. 所以, 一般用weak reference引用的对象是有价值被cache, 而且很容易被重新被构建, 且很消耗内存的对象.</p><p>​         在weak reference指向的对象被回收后, weak reference本身其实也就没有用了. java提供了一个<strong>ReferenceQueue</strong>来保存这些所     指向的对象已经被回收的reference. 用法是在定义WeakReference的时候将一个ReferenceQueue的对象作为参数传入构造函数.</p><p>软引用SoftReference：soft reference和weak reference一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时, soft reference指向的object才会被回收. 正因为有这个特性, soft reference比weak reference更加适合做cache objects的reference. 因为它可以尽可能的retain cached objects, 减少重建他们所需的时间和消耗</p></blockquote><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p><img src="https://user-images.githubusercontent.com/105496252/179641733-506a83e4-7c2d-4121-8930-152fdbedaf70.jpg" alt="标记清除法"></p><p>标记清楚就是对可达对象进行标记，不可达对象即认为是垃圾，进行清楚</p><p>通常分为两个步骤</p><ul><li>标记所有可到达的对象（reachable objects）</li><li>清除不可到达对象占用的内存空间</li></ul><blockquote><p>可达性行分析：</p><p>GC遍历内存中整体的对象关系图确定根对象（根对象的定义）</p><ul><li><p>栈中直接引用的对象</p></li><li><p>常量池中引用的对象</p><p>大致可以理解为正在使用的对象</p></li></ul><p>根对象对所有对象进行依赖查找，所有可以被遍历访问到的对象，对其进行标记，即为存活对象，也称为可达性 </p></blockquote><p>解决了循坏依赖的问题，但是存在短时间的线程暂停，这种现象为STW停顿（Stop The World Pause,权限暂停 ），暂停时间和堆内存的大小、对象的总数没有直接关系，而是同存活对象的数量来决定。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h3><p><strong>标记-清除</strong></p><p>即为上述所讲模式，不会对碎片进行整理</p><p><strong>标记-清除-整理</strong></p><p>上述模式以外，还会进行内存整理，但是会增加GC暂停时间</p><p><strong>标记-整理</strong></p><p><img src="https://user-images.githubusercontent.com/105496252/179641768-08b8d532-bcdc-414f-afc4-8925e49a4ba6.jpg" alt="标记-整理"></p><p>基于<strong>标记-清除-整理</strong>算法，创建新的内存用于存储幸存对象，同时复制和标记并发进行，可以减少GC时间，牺牲空间换取时间 </p><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>系统GC每次执行清除（sweeping）操作，JVN都必须保证“不可达对象”占用的内存被回收然后重用。虽然内存回收了，但会创建大量的内存碎片（类似于磁盘碎片），进而引发两个问题：</p><ul><li>对象创建时，执行写入操作越来越耗时，因为JVM系统需要花费更多的时间去寻找对应大小的内存空间</li><li>对象创建需要在一块连续的内存空间中分配内存。如果碎片问题非常严重，直至没有空闲片段能够存放新建的对象，就会发生内存分配错误（alloaction error）</li></ul><p>因此JVM启动GC收集垃圾时不仅仅需要标记和清除，还需要执行“内存碎片整理”。整个过程会让所有的可达对象进行依次移动，进而减少或者消除内存碎片</p><p><img src="https://user-images.githubusercontent.com/105496252/179641745-b7b88227-dc0b-4f4a-bd4e-2274a84fae7a.jpg" alt="碎片整理"></p><h2 id="分代设想"><a href="#分代设想" class="headerlink" title="分代设想"></a>分代设想</h2><p>垃圾收集需要停止程序的进行，如果收集的过程很长，就会大大影响系统的性能。为了解决这个问题，通过实验发现内存的对象大致分为两大类</p><ul><li>存活时间较长（这类对象比较少）</li><li>存活时间较短（这类对象比较多）</li></ul><p>因此将VM中将内存分为年轻代（后者）和老年代（前者），采用不同的算法用来提高GC的性能。</p><p>缺点：不同分代的对象依旧会存在相互引用，难以回收</p><p><img src="https://user-images.githubusercontent.com/105496252/179642938-26d22cd9-ec25-4d71-b2c7-ad38f3364eed.jpg" alt="对象年龄分布图"></p><h2 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h2><p>基于默认的JVM内存架构，对象创建时内存的分配过程如下</p><ol><li><p>编译器通过逃逸分析（JDK8默认开启），确认对象在堆或栈上分配</p></li><li><p>如果在堆上分配，则首先检测是否可以在TLAB（Thread Local Alloaction Buffer）上直接分配</p></li><li><p>如TLAB不能分配，则分到Eden加锁区分配（线程共享区）</p></li><li><p>如果Eden区无法分配对象，则执行Yong GC(Minor Collection)</p></li><li><p>如果Yong GC之后Eden仍不能分配存储对象，则直接分配到老年代 </p><blockquote><p>TLAB：线程本地应用缓存，在伊甸园区的私有区，空间小没有锁，效率快。如果不能分配，线程会再次申请，还是失败则会分配到伊甸园区</p></blockquote></li></ol><p><img src="https://user-images.githubusercontent.com/105496252/179641760-995aa12e-20b7-4281-9acc-8641bda4e52e.jpg" alt="YoungGC操作"></p><p>  Young GC</p><ul><li>GC触发时所有<strong>可达对象</strong>会被复制到一个幸存区（例如S1），S1如果无法存储这些对象会被直接复制到老年代</li><li>GC再次触发时Eden和S1的<strong>可达对象</strong>会被复制到S2，同时清空S1和Eden</li><li>GC再次触发时Eden和S2的<strong>可达对象</strong>会被复制到S1，同时清空S2和Eden，以次类推</li><li>每次GC幸存对象都会年龄+1，到达一定阈值直接分配到老年代（可用参数 -XX：+MaxTenuringThreshold 来指定上线，默认15）</li></ul><blockquote><p>s1和s2至少有一个是空的，用来存放下次GC未被收集的对象</p></blockquote><h2 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h2><p> 垃圾收集事件通常分为：</p><ul><li>Minor GC(小型GC)：年轻代GC，新对象分配频率越高，GC越多</li><li>Major GC（大型GC）：老年代GC</li><li>Full GC（完全GC）：整个堆的GC事件</li></ul><h2 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h2><p>下文出现的吞吐量= 运行用户代码的时间/（ 运行用户代码的时间+垃圾收集时间）</p><h3 id="算法搭配"><a href="#算法搭配" class="headerlink" title="算法搭配"></a>算法搭配</h3><ul><li>年轻代和老年代串行收集器：Serial GC</li><li>年轻代和老年代并行收集器：Parallel Gc</li><li>年轻代并行和老年代并发收集器：Parallel Gc New 和 CMS-Concurrent Mark and Sweep</li><li>G1收集器</li></ul><h3 id="Serial-GC串行收集器"><a href="#Serial-GC串行收集器" class="headerlink" title="Serial GC串行收集器"></a>Serial GC串行收集器</h3><p>参数配置： -XX：+UseSerialGC</p><p><strong>应用特点</strong></p><ul><li>内部仅一个线程执行垃圾回收</li><li>GC时Stop the world 时间较长</li></ul><p><strong>场景引用</strong></p><ul><li>JVM的客户端模式，实时性要求不高</li><li>适用于CPU个数或者核数较少且内存空间少的环境</li></ul><p><strong>算法运用</strong></p><ul><li>新生代<strong>标记-复制</strong>（存活对象少）</li><li>老年代<strong>标记-清除-整理</strong>（回收少，碎片多）</li></ul><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>Mostly Concurrent Mark and Sweep Garbage Collector</p><p>设计目标是追求更快的响应时间</p><p><strong>参数</strong></p><p>使用CMS配置  -XX:+UseConMarSweepGC, 默认开启 -XX:++UseParNewGC</p><ul><li>-XX:UseCMSCompactAtFullCollection 执行full GC后,进行一次碎片整理,整理的过程是独占的,会引起停顿的时间变长</li><li>-XX:+CMSFullGCsBeforeCompaction 设置进行几次full GC之后,进行一次碎片整理</li><li>-XX:ParallelCMSThreads 设定CMS线程数量(一般情况可约等于CPU数量)</li></ul><p><strong>应用特点</strong></p><ul><li><p><strong>空闲列表（free-lists）</strong>管理内存的回收，不对老年代进行碎片整理</p></li><li><p>在<strong>标记-清除</strong>阶段大部分工作和用户线程一起并发执行</p></li><li><p>优点是性能高,每次GC的时间都很短</p></li><li><p>缺点是CPU资源较少时,GC平均占用着,CMS会比并行GC的吞吐量小一些</p><p>老年代的碎片无法处理,特别是在堆内存设置非常大的情况下,GC几次full GC后碎片清理会进行不可预测甚至长时间的暂停</p></li></ul><p><strong>场景应用</strong></p><ul><li>适用于多个或者多核处理器，响应时间优先</li><li>CPU受限下，同用户竞争CPU，吞吐量少</li></ul><p><strong>算法运用</strong></p><ul><li>新生代并行的<strong>标记-复制</strong></li><li>老年代并发<strong>标记-清除</strong></li></ul><h3 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h3><p>并行收集器,利用多个或者多核CPU优势实现多线程并行GC操作</p><p><strong>配置参数</strong></p><p>使用Parallel GC配置  -XX:+UseParallelGC, 默认开启 -XX:++UseParallelOldaGC</p><ul><li>-XX:ParallelGCThread=20 设置并行收集器并行数，最好和处理器数目相等</li><li>-XX:MaxGCPauseMills=100 设置每次年轻代垃圾回收最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值</li><li>-XX:+UseAdaptiveSizePolicy 设置并行收集器自动选择年轻代大小和幸存区的比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用该收集器时一直打开</li><li>-XX:GCTimeRatio=99 设置吞吐量大小，默认值为99，就是将垃圾回收的时间设置成总时间的1%，它的值是0-100的整数值。假设值为n，则垃圾收集时间不得超过1/(1+n)</li></ul><p><strong>应用特点</strong></p><ul><li>利用CPU的多核特性执行多线程下的并行化GC操作</li><li>GC期间,所有CPU内核都在并行清理垃圾,暂停时间短</li><li>实现可控吞吐量和停顿时间（可配置）</li></ul><p><strong>场景运用</strong></p><ul><li>GC操作仍需暂停应用程序,GC不能打断,不适合低延迟要求场景，适用于需要高吞吐量而对暂停时间不敏感的场合</li><li>后台计算、后台处理的弱交互场景而非web交互场景</li></ul><p><strong>算法应用</strong></p><ul><li>年轻代<strong>标记-复制</strong>，对应Parallel Scavenge收集器</li><li>老年代<strong>标记-清除-整理</strong>，对应Parallel old收集器</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>在JDK8中属于准产品</p><p>一种工作于服务端模式的垃圾回收器，面向多核、大内存的服务器，在实现高吞吐量时，也满足了GC的停顿时间可控。未来G1计划全面取代CMS。</p><ul><li>可以像CMS收集器一样能够同时和应用线程一起并发执行</li><li>减少内存停顿时间</li><li>满足可预测的停顿需求</li><li>属于压缩型收集器，可以实现有效的空间压缩。消除大部分内存碎片问题</li></ul><p><strong>实现方式</strong></p><p>在G1中堆不再区分年轻代和老年代，二十划分为多个（通常是2048个）存放对象的<strong>小堆区</strong>（small heap regions）。每个小堆区可以是eden、survivor、old，请两者合起来为年轻代。</p><ul><li>每次GC只处理一部分<strong>小堆区</strong>，陈为此次的回收集（collection set）,收集所有年轻代和部分老年代的小堆区</li><li>类似于CMS，在并发阶段会事先估计每个小堆区存活对象的数量，垃圾最多的被优先收集。</li><li>基于<strong>停顿时间目标</strong>来选择需要回收、压缩的小堆区数量</li><li>G1基于标记、清理对应的region时，会将对象从一个或者多个region中复制到另一个region，在这个过程中伴随释放和压缩内存</li><li>基于多核并行执行，满足其他收集器所不具备的（CMS不能压碎碎片、ParallelOld只能较长时间的整堆压缩）</li></ul><blockquote><p>G1不是一个实时的收集器，它只是近最大可能来满足设定停顿时间。基于以往的收集数据和指定的停顿时间来确定收集几个regions</p><p>region：1-2m，最多200个，最大支持内存64G</p></blockquote><p><strong>配置参数</strong></p><p>-XX：+UseG1GC 启用G1收集器</p><ul><li><p>-XX：MaxGCPauseMillis=200 </p><p>设置最大停顿时间指标，是一个软指标，JVM会尽力区完成这个指标，默认值为200毫秒</p></li><li><p>-XX：InitiatingHeapOccupancyPercent=45</p><p>启动GC时<strong>整个堆</strong>内存的占比，默认45即45%</p></li></ul><p><strong>特点</strong></p><ul><li>内存运用比较弹性</li><li>支持并行和并发</li></ul><p><strong>运用场景</strong></p><ul><li><p>FullGC发生相对比较频繁或总时长比较长</p></li><li><p>对象分配或对象进入老年代比例波动大</p></li><li><p>较长内存停顿</p><blockquote><p>如果其他收集器运用良好，不建议更换G1</p></blockquote></li></ul><p><strong>算法分析</strong></p><ul><li>年轻代<strong>标记复制</strong></li><li>老年代<strong>标记复制整理</strong></li></ul><p><strong>关键步骤</strong></p><ol><li>初始标记：属于YoungGC，具有STW，对持有老年代引用的survivor(root)进行标记</li><li>根区扫描：并发执行，对root进行扫描</li><li>并发标记：找出整个堆中存活对象，空区域标记为”x“，会被young GC中断</li><li>再次标记：完全堆堆中存活对象标记，采用比CMS更快的SATB算法</li><li>清理：并发执行，统计小队去存活对象，并对小堆区进行排序，清理垃圾，释放内存</li><li>复制/清理：小堆区中未被清理的对象进行复制，然后清理</li></ol><p><strong>后记</strong></p><p>值得一提的是HotSpot工程师主要精力一直放在不断改进G1上，新版本JDK会带来新的功能和优化</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="/2022/07/19/lei-jia-zai/"/>
      <url>/2022/07/19/lei-jia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p><img src="https://user-images.githubusercontent.com/105496252/179641689-11015dbb-fe5a-47ee-8745-36b5f473c252.jpg" alt="类加载过程"></p><ul><li>验证：是否符合jvm规范</li><li>准备：分配足够的内存空间</li><li>解析： 符号信息和引用的转换</li><li>初始化：默认初始化，再赋值</li><li>使用：构建对象</li><li>卸载：几率比较少，也会被GC</li></ul><p><strong>以下按照顺序进行</strong></p><h2 id="加载分析"><a href="#加载分析" class="headerlink" title="加载分析"></a>加载分析</h2><p>加载过程：加载、验证、准备、解析、初始化</p><p><strong>解析</strong>开始的顺序不确定，<strong>其他开始</strong>的时间按照顺序执行，同时这四个阶段也不一定按照顺序完成</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p><img src="https://user-images.githubusercontent.com/105496252/179641697-de4292c0-eabc-42cb-9281-521a5a306f04.jpg" alt="类加载过程"></p><ul><li>通过类的全限定名来获取定义的二进制字节流</li><li>将字节流代表的静态存储结构转化为方法区的运行时数据结构</li><li>再JAVA堆中生成一个java.lang.Class对象，作为访问这些数据的入口</li></ul><h3 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h3><p>从三个地方加载</p><ul><li>JDK类库的类</li><li>第三方类库（spring、maven等）</li><li>应用程序类库（自己写的类，依赖前二者）</li></ul><h3 id="加载方式以及时机"><a href="#加载方式以及时机" class="headerlink" title="加载方式以及时机"></a>加载方式以及时机</h3><ul><li><p>隐式加载</p><ul><li>访问类的静态成员（成员变量、静态方法）</li><li>构建类的实例对象（使用new关键字 和 反射构建）</li><li>构建子类实例对象（双亲委派模式，会先行加载父类类型）</li></ul></li><li><p>显示加载</p><ul><li>ClassLoader.loadClass(….)</li><li>Class.forName(….)</li></ul></li></ul><h4 id="显示加载"><a href="#显示加载" class="headerlink" title="显示加载"></a>显示加载</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">ex<span class="token punctuation">.</span>java<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>loader</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token class-name">Static</span> <span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"classA"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>main<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">ClassLoader</span> loader <span class="token operator">=</span> <span class="token class-name">TestClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span>getClassLoaderloader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"ex.java.jvm.loader"</span><span class="token punctuation">)</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上classA被加载,静态代码块A不加载</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//替换main的内容</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"ex.java.jvm.loader"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>以上classA被加载,静态代码块A加载</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//替换main的内容</span><span class="token class-name">ClassLoader</span> loader <span class="token operator">=</span> <span class="token class-name">TestClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span>getClassLoader<span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"ex.java.jvm.loader"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>loader<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>以上classA被加载,静态代码块A不加载</strong></p><h4 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">static</span><span class="token punctuation">{</span> <span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"A静态块"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"A消息"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>main<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">sout</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>cap<span class="token punctuation">)</span>    <span class="token comment">//A.doPrint();</span>    <span class="token comment">//new 一个继承A的类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上三种方式classA都被加载,静态代码块执行</strong></p><h2 id="连接分析"><a href="#连接分析" class="headerlink" title="连接分析"></a>连接分析</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合虚拟机的要求,不会危害虚拟机的安全</p><p>通过四个阶段完成校验</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码合法性验证</li><li>符号引用验证</li></ul><blockquote><p>验证阶段是非常重要却又非必须，如果引用的类经过反复的验证，可以采用-Xverify：none参数来关闭大部分的类验证，缩短虚拟机类加载的时间</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量分配内存并设置类变量默认值（在方法区中）</p><blockquote><p>默认值：0、null、false……. </p><p>如果是常量，在准备阶段就会赋值（代码给定的值）</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池的符号引用替换成直接引用</p><p>当一个java文件编译成class之后，方法都是以符号引用的方式保存。而在加载类时，部分符合条件的符号引用会被转换成<strong>“直接引用”</strong>，这个过程我们称之为<strong>“解析（Resolution）”</strong>。而符合这种条件的方法有：静态方法、私有方法、构造方法、父类方法。它们在类加载的的解析阶段就会将符号引用解析为该方法的直接引用。</p><ul><li>符号引用：一组符号，可以是任何字面量，用文本形式来表示引用关系</li><li>直接引用：直接指向目标的指针、相对偏移量或者一个间接定位到目标的句柄（jvm可以直接使用的数据形式）</li></ul><h2 id="初始化分析"><a href="#初始化分析" class="headerlink" title="初始化分析"></a>初始化分析</h2><p>此阶段为类加载的最后一个阶段，让我们的自定义加载器加入进来</p><p>因为系统的ClassLoader只会加载指定目录下的class文件,如果想加载自己的class文件,那么就可以自定义一个ClassLoader，甚至通过远程热更新配置文件，让自定义加载器加载不同的类等等功能</p><p><strong>java中对类变量初始值的设定方法</strong></p><ul><li>声明类变量时指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>java程序对类的使用方式为两种</strong></p><ul><li>主动使用：会执行加载、连接、初始化静态域</li><li>被动使用：会执行加载、连接，不会初始化静态域</li></ul><p>例如：通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化</p><h2 id="类加载器概要"><a href="#类加载器概要" class="headerlink" title="类加载器概要"></a>类加载器概要</h2><p>负责将类读到内存的对象，常见方法有</p><ul><li>getParent()  返回类加载器的父类对象</li><li>loadClass(String name) 加载名称为name的类</li><li>findClass(String name) 查找名称为name的类</li><li>findLoadedClass（String name） 查找名称为name的已加载类</li><li>defineClass（String name,byte[] b,int off,int len）把字节数组b种的内容转换为java</li><li>等等</li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><p><img src="https://user-images.githubusercontent.com/105496252/179642566-b6412c13-c718-4b56-af58-cff1f7e85678.jpg" alt="类加载层级"></p><p><strong>从下往下依次</strong></p><ul><li>启动类加载器：底层为C、C++,加载启动相关类。在java中  <code>getParent() </code>  拿不到该类，返回null即表示由此类加载加载</li><li>扩展类加载器：拓展的资源</li><li>应用程序加载器：自己写的类加载</li><li>自定义加载器 ：spring、tomcat等容器都有自己定义的加载器</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>保证了同一个类只被一个加载器加载</p><p>当一个加载器加载某个类时</p><ul><li>首先查看自己是否加载过该类，有则返回，没有则委托给父类加载，依次递归</li><li>父类无法加载时，自己加载</li><li>自己无法加载，抛出异常</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p><strong>直接继承classLoader，重写 <code>findClass(String name)</code> 方法，运行自定义加载器过程</strong></p><ul><li>会先去寻找父类加载器，加载指定当前类路径下的包名和类名</li><li>当前类路径下如果没有，就从重写的  <code>findClass(String name)</code>  方法中去查找，通过自定义加载器加载</li></ul><p><strong>基于URLClassLoader继承ClassLoader，从指定目录、jar包、网络中加载指定的类资源</strong></p><p>在类加载器中的构造方法可以指定父类加载器为null，取消双亲委派</p><p><strong>热替换</strong></p><p>再以上指定路径下的class文件进行文件替换，实现在线更新</p><p>要想实现Java类的热替换，首先必须要让系统中同名类的不同版本实例的共存，要想实现同一个类的不同版本的共存，必须要通过不同的类加载器来加载该类的不同版本。另外，为了能够绕过Java类的既定加载过程，需要实现自己的类加载器。</p><p><strong>源代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">String</span> basedir<span class="token punctuation">;</span> <span class="token comment">// 需要该类加载器直接加载的类文件的基目录</span><span class="token keyword">private</span> <span class="token class-name">HashSet</span> className<span class="token punctuation">;</span> <span class="token comment">// 需要由该类加载器直接加载的类名</span><span class="token keyword">public</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> basedir<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clazns<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定父类加载器为 null </span><span class="token keyword">this</span><span class="token punctuation">.</span>basedir <span class="token operator">=</span> basedir<span class="token punctuation">;</span>className <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">loadClassByMe</span><span class="token punctuation">(</span>clazns<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//获得所有文件的完整路径以及类名,刷入缓存    </span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">loadClassByMe</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clazns<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clazns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">loadDirectly</span><span class="token punctuation">(</span>clazns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>className<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>clazns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//拼接文件路径及文件名</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">loadDirectly</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>basedir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//路径中的 .  替换为 /</span><span class="token class-name">String</span> classname <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token class-name">File</span><span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">File</span><span class="token punctuation">.</span>separator <span class="token operator">+</span> classname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">File</span> classF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cls <span class="token operator">=</span> <span class="token function">instantiateClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>classF<span class="token punctuation">)</span><span class="token punctuation">,</span> classF<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> cls<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//读取并加载类</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">instantiateClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> fin<span class="token punctuation">,</span> <span class="token keyword">long</span> len<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> raw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> len<span class="token punctuation">]</span><span class="token punctuation">;</span>fin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>raw<span class="token punctuation">)</span><span class="token punctuation">;</span>fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> raw<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> raw<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//    </span><span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span><span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//判断类是否已经加载过</span>cls <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>className<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cls <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>cls <span class="token operator">=</span> <span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cls <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token function">resolveClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> cls<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">// 每次都创建出一个新的类加载器</span><span class="token class-name">CustomClassLoader</span> customClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">(</span><span class="token class-name">CustomClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">"\").getFile(), new String[] { "</span><span class="token class-name">Foo</span>" <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> cls <span class="token operator">=</span> customClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> foo <span class="token operator">=</span> cls<span class="token punctuation">.</span>newInstanc <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Method</span> m <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"sayHi"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要在基目录下创建一个类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">implements</span> <span class="token class-name">FooInterface</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hi\t我是第一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口任意创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FooInterface</span> <span class="token punctuation">{</span>     <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重新编译一份Foo.class文件,替换到目标路径之下,实现自动更新</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM概况</title>
      <link href="/2022/07/19/jvm-gai-kuang/"/>
      <url>/2022/07/19/jvm-gai-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><ul><li>有效防止内存泄漏</li><li>优化线程锁的使用</li><li>科学地进行内存回收</li><li>提高系统吞吐量</li><li>降低延时,提高性能</li></ul><h2 id="字节码底层执行顺序"><a href="#字节码底层执行顺序" class="headerlink" title="字节码底层执行顺序"></a>字节码底层执行顺序</h2><p><img src="https://user-images.githubusercontent.com/105496252/179641555-3a3abbab-2ac7-4362-a12d-c1da5141190c.png"></p><p>在主流的JVM(如HotSpot)中实现了两种执行方式</p><p><img src="https://user-images.githubusercontent.com/105496252/179641658-53d2596c-5674-42f9-8f1f-83f4cc7c17df.jpg" alt="代码执行方式"></p><ul><li>热点代码 : 一般泛指循坏或者高频使用的方法</li><li>解释执行器 : 负责将字节码翻译成机械码并执行</li><li>编译执行器 : 负责即时编译(just-in-time compilation , JIT)</li></ul><blockquote><p>JIT :</p><p>用以提高代码效率,基于这种技术,字节码编译成平台相关的原生机器码,并进行各个层次的优化。这些机器码会被缓存起来，以便下次快速使用（会增加内存负担）</p></blockquote><h2 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h2><p>cmd中 java -version 查看</p><p><strong>Server模式</strong>（64bit 默认）</p><ul><li>启动速度慢，进入稳定期后速度相比较更快</li><li>重量级虚拟机（对锁\内存等使用方面进行优化）</li></ul><p><strong>Client模式</strong></p><ul><li>启动速度快，稳定后速度相对速度慢</li><li>轻量级虚拟机</li></ul><h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><p>主要有三大部分</p><ul><li>类加载区：加载类到内存</li><li>运行时数据区：负责存储数据信息</li><li>执行引擎：负责调用对象执行业务（jit、gc、解释器）</li></ul><p><img src="https://user-images.githubusercontent.com/105496252/179642336-24babf73-a79c-4cc7-80dc-98d289cf9953.jpg" alt="JVM架构"></p><h3 id="运行内存架构"><a href="#运行内存架构" class="headerlink" title="运行内存架构"></a>运行内存架构</h3><p>  <img src="https://user-images.githubusercontent.com/105496252/179641680-d6e44edd-1d78-4403-a751-af1a20dbc850.jpg" alt="运行内存结构"></p><p><strong>堆区域</strong></p><p>GC的主要管理区域</p><ul><li><p><strong>年轻代</strong>首先进入</p><p>优先放置其中的<strong>伊甸园区</strong>，待区域满了，GC启动，转入幸存区的<strong>From区</strong></p><ul><li><p>From和To区中相互转化，且永远有一个空的</p></li><li><p>再一次GC(伊甸园和From皆有回收)，From中没有被回收的资源转入To,</p></li><li><p>To转换为From，且资源年龄+1</p></li><li><p>年龄大的资源被GC回收，进入<strong>老年代</strong></p></li></ul></li><li><p><strong>老年代</strong>进入方式</p><ol><li>年轻代GC至老年代</li><li>年轻代空间满即伊甸园空间不足，创建对象时直接出生再老年代（部分小对象也有可能进入虚拟机栈）</li></ol></li></ul><p><strong>方法区（元空间、持久代）</strong></p><p>​         在JDK8中是一块本地内存（脱离了JVM），由OS动态配置，可以手动设置最大空间</p><p><strong>程序计数器</strong></p><ul><li>线程启动时创建，线程私有</li><li>记录当前正在执行的虚拟机字节码指令地址</li><li>该区域不会存在内存溢出</li></ul><p><strong>栈</strong></p><ul><li>存储栈帧对象</li><li>方法的一次调用就会经历一次压栈和出栈</li><li>小对象（十几个bytes）且没有逃逸（没有全局声明）会创建在此</li><li>容易在递归时（未使用尾递归优化）发生栈内存溢出</li></ul><p><strong>本地方法栈</strong></p><p>调用本地的方法，java调用非java代码的接口</p><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul><li>interpreter（解释器）：即时运行，变编译边执行代码</li><li>JIT ：缓存热点代码，下次调用免编译直接运行</li><li>垃圾收集器：收集垃圾对象</li></ul><h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><p> <strong>堆主要着手以下方面</strong></p><ul><li><p>-XMS   堆空间的最小大小</p></li><li><p>-XMX   堆空间的最大大小</p></li><li><p>-XX： NewSize   新生代最小空间</p></li><li><p>-XX： MAXNewSize   新生代最大空间</p></li><li><p>-XX： NewRatio   老年代和新生代的比值</p></li><li><p>-XX： SurvivorRatio   eden 和 <strong>单个</strong>Survivor的比值  例如8 等于 eden ：Survivor = 8 ：2</p></li><li><p>-Xss  每个线程大小</p></li></ul><p><strong>方法区（JDK8）</strong></p><ul><li>-XX：MetaspaceSize   最小空间</li><li>-XX：MaxMetaspaceSize   最大空间</li></ul><p><strong>栈</strong></p><ul><li>-Xss  越小可以创建的线程越多，注意OS对单个进程可以创建的线程数最多在3000-5000之间</li></ul><h2 id="常用监控工具"><a href="#常用监控工具" class="headerlink" title="常用监控工具"></a>常用监控工具</h2><p>1、jps 进程监控工具</p><p>​ 查看虚拟机正在运行的进程信息，可追踪到应用进程ID 、启动类名、文件路径。</p><p>2、jstat性能监控工具</p><p>​用于监视内存各个区域的使用情况、垃圾回收情况</p><p>3、jinfo 参数配置监控工具</p><p>​查询和调整JVM 配置信息。</p><p>4、jmap内存监控工具</p><p>​生存堆内存快照文件，查询堆内存配置和使用状况。</p><p>5、jstatck线程监控工具</p><p>​ 生成虚拟机当前时刻的线程快照文件。</p><p>6、可视化工具VisualVM（类似的很多）</p><p>​jdk自带，可以进行本地和远程监控</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/07/07/pai-xu/"/>
      <url>/2022/07/07/pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="几种慢速排序方法"><a href="#几种慢速排序方法" class="headerlink" title="几种慢速排序方法"></a>几种慢速排序方法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的思想主要是交换排序</p><p>**基本思想:**两两比较相邻记录的关键字,如果反序就交换,直到没有反序的记录为止</p><p>**时间复杂度:**O(n<sup>2</sup>)      最小值n-1次查找      最大值n(n-1)/2次查找且做等量级移动</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>简单选择排序(Smple Selection Sort)就是通过<strong>n-i次关键字间</strong>的比较,从n-i+1个记录中选择出关键词最小的记录,并和第i个记录进行交换 ( 1&lt;= i &lt;=n )</p><p>**时间复杂度:**O(n<sup>2</sup>), </p><p>比较次数恒定为n(n-1)/2</p><p>交换次数最小为0，最大为n-1</p><p>复杂度相对于冒泡排序略低  </p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序就是将一个记录插入已经排好序的有序表中,从而得到一个新的、记录数＋1的有序表</p><p><strong>时间复杂度：</strong>O(n<sup>2</sup>)</p><p>平均的比较和移动次数为<strong>n<sup>2</sup>/2</strong>，性能高于直接插入和冒泡</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>先简单介绍下<strong>基本有序</strong>：最小的关键词基本在前面，不大不小的基本在中间，最大的基本在后面</p><p>因此我们采用<strong>跳跃分割</strong>的策略：将相距某个<strong>增量</strong>的记录组成一个子序列，在子序列进行插入排序后就是基本有序，使得排序效率提高。</p><p>性能主要取决于<strong>增量</strong>的值，研究指出为dlta[k]=2<sup>t-k+1</sup>-1（0&lt;=k&lt;=t&lt;=log<sub>2</sub>(n+1)）时效率较高,<strong>时间复杂度：</strong>O(n<sup>3/2</sup>)</p><h2 id="堆积法"><a href="#堆积法" class="headerlink" title="堆积法"></a>堆积法</h2><p>堆是具有下列性质的完全二叉树</p><ul><li>每个结点的值都大于或者等于其左右孩子结点的值，成为大顶堆</li><li>每个结点的值都小于或者等于其左右孩子结点的值，成为小顶堆</li></ul><h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>以大顶堆为例子</p><ul><li>将待排序数组构成一个大顶堆，将顶端结点和堆数组末尾互换</li><li>将剩余的n-1个序列重新构成一个大顶堆，得到n-1中的次大值</li><li>重复上述</li></ul><p>问题在于<strong>大顶堆的构建</strong>和<strong>剩余元素重构大顶堆</strong></p><p>具体算法略过，讨论一下算法的复杂度</p><ul><li><p>堆构建的时间复杂度复杂度为：<em><strong>O（n）</strong></em></p></li><li><p>单次重构的时间复杂度为：<em><strong>O（logi）</strong></em>，堆顶获取n-1次。</p><p>总体花费：<em><strong>O（nlogn）</strong></em></p></li></ul><p>综上堆排序时间为<em><strong>O（nlogn）</strong></em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>堆排序空间占用较高，但是排序依旧不够稳定（记录的跳跃性），不适合待排序序列较少的情况</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>2路归并排序的原理是</p><ul><li>假设初始序列有n个记录，则可以看成是n个有序的子序列，每个子序列长度为1</li><li>然后两两归并，得到 n/2 个长度为2 或者为 1 的有序子序列</li><li>重复两两并归</li></ul><p><strong>复杂度分析</strong></p><p>时间复杂度：<em><strong>O（nlogn）</strong></em></p><p>空间复杂度：<em><strong>O（n+logn）</strong></em>  递归情况</p><p>​<em><strong>O（n）</strong></em>  非递归情况   因此最好使用非递归算法</p><p>属于比较占用内存但是效率高且稳定的算法</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序属于从冒泡排序进阶而来</p><p>快速排序的思想：</p><p>通过一趟排序将待排记录分割为两部分，一部分的关键字比另一部分小，将这两部分记录继续进行排序。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort2</span> <span class="token punctuation">{</span>        <span class="token comment">//三个水桶原理，进行数据的交换</span>       <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> j <span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>           arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>start<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> end<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span>j <span class="token operator">=</span> end<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;=</span>k<span class="token punctuation">)</span>                    j<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>k<span class="token punctuation">)</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>时间复杂度:</p><p>最好的情况 <em><strong>O（n）</strong></em></p><p>最坏的情况 <em><strong>O（n<sup>2</sup>）</strong></em></p><p>平均时间复杂度为 <em><strong>O（nlog<sub>2</sub>n）</strong></em></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>将快速排序的递归实施尾递归优化</li><li>优化选取中间值的方法(三数取中、九数取中)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>start<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> end<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>小数组是，high或者low的值小于7（也有资料显示50），使用直接插入求解</li><li>优化不必要的交换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列查找表(哈希表)</title>
      <link href="/2022/07/05/san-lie-cha-zhao-biao-ha-xi-biao/"/>
      <url>/2022/07/05/san-lie-cha-zhao-biao-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="散列查找表"><a href="#散列查找表" class="headerlink" title="散列查找表"></a>散列查找表</h1><p>之前我们的查找,都需要通过比较a[i] 和 key</p><ul><li><p>顺序查找的方式是 “=” 还是 “!=”</p></li><li><p>折半查找的方式是 “&gt;” 还是 “&lt;”</p></li><li><p>在树的结构中依旧包含了 &lt;  &gt;  =</p></li></ul><p>无论如何比较都不可避免,能否存在直接通过关键词key找到记录的内存存储位置呢?</p><p>这就是我们要讨论的<strong>散列技术</strong></p><h2 id="散列技术"><a href="#散列技术" class="headerlink" title="散列技术"></a>散列技术</h2><p>散列技术是在记录的位置和它的关键字之间建立一个确定的对应关系  <em><strong>f</strong></em></p><p>使得每个关键字key都有对应的存储位置   <em>f(key)</em></p><p>在这里我们把这种对应关系 <em>f</em> 称为<strong>散列函数</strong>,又称为<strong>哈希(hash)函数</strong></p><p>根据这种思想,采用散列技术将记录存储在一块<strong>连续</strong>的存储空间中,这块连续存储空间称之为<strong>散列表</strong>或者<strong>哈希表</strong>,关键字所对应的记录存储位置我们称之为<strong>散列地址</strong></p><h2 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h2><ul><li>在存储时,通过散列函数计算记录的散列地址,按此地址存储该记录</li><li>在查找时,通过散列函数计算记录的散列地址,按此散列地址访问该记录</li></ul><p>所以,<strong>散列函数既是一种存储方法,也是一种查找方法</strong></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对比其他查找结构</p><ul><li>线性表、树、图都具有一定的逻辑关系</li><li>散列技术记录之间没有逻辑关系，记录只与关键字有关</li></ul><p>因此 散列表是面向查找的存储结构，最适合求解的问题：<strong>查找与给定值相等的记录</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>hash表的重点是设计一种简单、均匀、存储利用率高的的散列函数</p><p>如果出现了key<sub>1</sub> != key<sub>2</sub> ，但是<em>f</em>(key<sub>1</sub> )  = <em>f</em>(key<sub>2</sub> ) ，这种表现称之为哈希冲突（collision）,并且把key<sub>1</sub>和key<sub>2</sub> 称之为这个散列函数的同义词（synonym）</p><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>优秀散列函数的定义：</p><ol><li>计算简单（起码低于其他查找技术和关键字比较的时间）</li><li>散列地址的均匀分布 （保证存储空间有效利用、减少处理哈希冲突的时间）</li></ol><p>以下介绍几种常见的散列构造函数（有些类似于密码学，将原来的数字按某种规律变成另一个数字）</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>取关键字的某个线性函数值为散列地址<br>$$<br>f(key) = a*key + b<br>$$</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>例如身份证号码，前几位数字相同，后几位数字运用散列函数</p><p>**抽取方法:**使用关键字的一部分来计算散列函数</p><p><strong>使用范围：</strong>适合处理关键字特别多、事先知道关键字的分布、关键字若干位<strong>分布</strong>均匀</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p><strong>用法：</strong>将关键字平方之后取中间三位数</p><p><strong>适用：</strong>不知道关键字分布、位数不多</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p><strong>用法：</strong>将关键字从左到右分割成位数相等的几部分（最后一部分可以小一些），这这几部分相加求和，根据散列表长，取最后几位为散列地址</p><p>如果分布不均匀，可以将数据反转一下，如将下表的987 转为789</p><blockquote><p>若散列表长为3</p><p>987654321—— 987 + 654 + 321 + 0 = 1962</p><p>求最后三位为 962</p></blockquote><p><strong>适用：</strong>不需要知道关键字分布、关键字比较多</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>最常用的散列函数，对一个散列表长度为m的散列函数公式为，mod为取余数<br>$$<br>f(key) = key;mod ,p(p&lt;=m)<br>$$</p><ul><li>不仅可以对关键字直接取模，也可以折叠、平方后再取模</li><li>关键的方法在于选择合适的P，减少hash冲突</li><li>根据经验，p为小于或者等于表厂m（最好接近m）的<strong>最小质数</strong>或者不包含小于20质因子的合数</li></ul><h4 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h4><p><strong>用法</strong><br>$$<br>f(key) = random(key)<br>$$<br><strong>适用：</strong>关键字长度不等</p><p><strong>random函数考虑因素</strong></p><ul><li>计算散列地址的时间</li><li>关键字长度</li><li>散列表大小</li><li>关键字分布情况</li><li>记录查找的频率</li></ul><h2 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h2><p>哈希冲突在所难免，所以有了后续的处理方法</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p><strong>所谓开放地址法就是发生了哈希冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并记录</strong><br>$$<br>f1（key）=(f(key) + di)MOD;m:(di=1、2、3、4…….m-1)<br>$$<br>简单得说，就是在hash地址冲突时，将计算出的结果地址向下延续n位，直到有空位</p><p><strong>我们将这种解决冲突的开放地址法称之为线性探测法</strong></p><ul><li>本来就不是同义词的关键字取争夺同一个地址时，我们称之为<strong>堆积</strong></li><li>堆积的出现大大影响了查找和记录的效率</li></ul><p>为此还有其他的开放地址方法</p><ul><li><p>二次探测法：将d<sub>i</sub>的递增改为平方</p><p>其中d<sub>i</sub>=1、-1、2、-2、4…….q<sup>2</sup>、-q<sup>2</sup>（q &lt;= m/2）</p></li><li><p>随机探测法：d<sub>i</sub>是一个随机数列</p></li></ul><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>发生hash冲突时采用备用的散列函数</p><p>优势是使得关键字不发生集聚，缺点是增加了计算时间</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>散列地址变成指针指向一个单链表</p><p>缺点是带来了查找时遍历单链表的性能损耗</p><h3 id="公共溢出法"><a href="#公共溢出法" class="headerlink" title="公共溢出法"></a>公共溢出法</h3><p>将所有冲突的关键字存入一个公共的溢出区来存放</p><p>查找时先计算散列地址的值，比较后若是相等就取出；如果不相等就去溢出区进行顺序查找</p><p><strong>适用于冲突比较少的情况</strong></p><h2 id="查找实现"><a href="#查找实现" class="headerlink" title="查找实现"></a>查找实现</h2><ul><li>首先定义散列表结构和基本常数</li><li>对散列表进行初始化</li><li>定义散列函数（函数可以更具情况更改算法）</li><li>插入时计算散列地址，若地址存在关键字，进行hash冲突处理</li><li>查找和插入类似，额外做一个不存在关键字的判断</li></ul><h2 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h2><p>如果没有冲突，hash表的时间复杂度为最低 :  <em><strong>O（1）</strong></em></p><p>可惜哈希冲突在所难免，需要额外处理的计算，那么平均查找长度取决哪些因素呢？</p><p>其中散列函数<strong>是否均匀</strong>对查找性能是几乎不用考虑的，其主导的有以下</p><h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h3><p>这个浅显可以理解</p><h3 id="散列表的填装因子"><a href="#散列表的填装因子" class="headerlink" title="散列表的填装因子"></a>散列表的填装因子</h3><p><strong>填装因子α：</strong>填入表中的记录个数/散列表长度</p><p>其中α表示散列表的装满程度，α越大，发生哈希冲突的情况越多</p><p>为此我们在了解记录个数n的情况下，总可以选择一个合适的填装因，以便将平均查找长度限定在一个长度范围内。通常是将散列表空间设置得比查找集合大，一牺牲空间换取时间效率</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多路查找树(B树)</title>
      <link href="/2022/07/03/duo-lu-cha-zhao-shu-b-shu/"/>
      <url>/2022/07/03/duo-lu-cha-zhao-shu-b-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h1><p><strong>概念 :</strong> </p><p>回忆起AVL树</p><ul><li><p>每一次插入或删除总是为了保持树的平衡性而旋转,增加了性能的消耗。</p></li><li><p>一个结点只能存储一个元素，在元素非常多时，树的高度和度非常大，使得<strong>内存存取外存</strong>次数多</p></li></ul><p>所以，我们引入了一种<strong>绝对平衡</strong>且单结点可以存储<strong>多个元素的</strong>树，即为多路查找树</p><p><strong>具体实现</strong></p><ul><li>2-3树</li><li>2-3-4树</li><li>B树</li><li>B+树</li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>2-3以及之后的2-3-4树都属于特殊的B树</p></li><li><p>其<strong>任意节点</strong>到它所有<strong>叶子节点的深度</strong>都是相等的</p></li><li><p>每一个结点有<strong>2个(2结点)<strong>或者</strong>3个(3结点)</strong></p><ul><li><p>一个2结点包含一个元素,两个孩子</p><p>构成与二叉树类似,不过只存在<strong>空树</strong>或者<strong>满树</strong>(两个孩子)</p></li><li><p>一个3结点包含一大一小两个元素,三个孩子</p><p>值的比较：<strong>L&lt;P1&lt;M&lt;P2&lt;R</strong></p><p>同时也只能存在空树或者满树</p></li></ul></li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>类似于二叉树，插入操作发生在<strong>叶子结点</strong>，不同的是会发生结构的连锁反应</p><p>有一下几种情况，用近python格式伪码呈现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 插入叶子结点C是二结点树        C成为三结点树        <span class="token keyword">return</span>    <span class="token keyword">if</span> 插入叶子结点C是三结点树<span class="token keyword">if</span> 双亲P是二结点树        P成为三结点树        <span class="token keyword">return</span>    <span class="token keyword">if</span> 双亲P是三结点树P拆分为两颗二结点树        <span class="token keyword">or</span>         整个树的高度增加    <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>插入的逆过程</p><ul><li><strong>第一种情况：</strong>删除的叶子结点属于3结点的位置（双亲属于3结点树）</li></ul><p>​ 直接删除，3结点变2结点</p><ul><li><p><strong>第二种情况：</strong>删除的叶子结点C属于2结点的位置</p><p>分四种情况</p><ul><li>双亲<strong>2结点</strong>，有个<strong>3节点</strong>的孩子（C的兄弟）<strong>：</strong>删除C，以双亲进行旋转</li><li>双亲<strong>2结点</strong>，有个<strong>2节点</strong>的孩子（C的兄弟）<strong>：</strong>删除C，以双亲的双亲进行旋转</li><li>双亲<strong>3结点：</strong>删除C，双亲拆分为2个2结点树</li><li>满二叉树<strong>：</strong>删除C，降低树的层数</li></ul></li><li><p><strong>第三种情况：</strong>删除的节点非叶子结点</p></li></ul><p></p><p>​中序遍历该结点的前驱或者后驱元素，进行补位</p><h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>属于23树的拓展，基本属性相同，多了一个<strong>4结点</strong>的使用。</p><p>其包含了小中大三个元素和4个孩子（或者没有孩子）</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种平衡的多路查找树，结点最大的孩子数目为B树的阶（order）</p><p>可以先从下面的2-3树开始理解，再看B树的内容</p><p>一个m阶的B树具有如下属性</p><ul><li><p>如果根结点不是叶结点。则至少有两颗树</p></li><li><p>每个非根的分支结点都有k-1个元素和K个孩子,每一个叶子结点n都有k-1个元素</p><p>其中  <code>(m/2) &lt;= k &lt;= m</code>     其中 / 取整</p></li><li><p>所有叶子结点都位于同一层次</p></li><li><p>与其他平衡二叉树类似，B-树查找、插入和删除操作的时间复杂度为<em><strong>O(logn)</strong></em> 量级</p><p>其中数据排列具有以下特征</p></li><li><p>所有分支结点包含以下数据信息(n,A<sub>0</sub>,K<sub>1</sub>,A<sub>1</sub>,K<sub>2</sub>,A<sub>2</sub>……K<sub>n</sub>,A<sub>n</sub>)</p></li><li><p>n为关键字个数    <code>(m/2)-1 &lt;= n &lt;= m-1</code>  </p></li><li><p>所有的A、K同下标正相关</p></li><li><p>​      A<sub>n-1</sub>   &lt;=     K<sub>n</sub>    &lt;=    A<sub>n</sub>  </p><p><img src="https://user-images.githubusercontent.com/105496252/177155333-0797edde-8e40-406e-aa9f-05f4f7dad702.jpg" alt="B树结构特征"></p></li></ul><h3 id="结构优势"><a href="#结构优势" class="headerlink" title="结构优势"></a>结构优势</h3><p>减少内存与外存的的数据交换次数(例如减少硬盘读写)</p><p>同时数据内容过于庞大不能够一次性读进内存</p><p>可以说是专门为<strong>内外存</strong>数据交互准备的</p><ul><li><p>将B树阶数同硬盘存储页面大小相匹配</p><p>例如: 1001阶、高度2的树，可以存储10亿个关键字</p></li><li><p>将根结点永久保存在内存中</p></li><li><p>查找某个关键字至多需要2次硬盘读写</p></li></ul><p>对于查找n个关键字的m阶B树，查找一个数据，仅仅支持<strong>随机查找</strong></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>b树虽然利于内外村交互，但是再查找过程中，对于硬盘的遍历还是存在缺陷的。</p><p>再中序遍历中，尤其是再孩子都处于不同硬盘页面时，会进行多次的页面转换、重复遍历（尤其是对<strong>结点</strong>也可以说是双亲的元素）</p><p>为了解决多次遍历的问题，引入了B+树</p><p><img src="https://user-images.githubusercontent.com/105496252/177320624-f955406f-1e44-4f39-9be6-9cd31fe56d46.png" alt="B+树"></p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>对比b树</p><ul><li>有n棵树的结点有n个关键字</li><li>所有叶子结点包含全部关键字的信息，以及指向这些关键字记录的指针，叶子结点本身依据关键字大小从小到大顺序链接</li><li>所有的分支结点可以看成索引，记录了叶子子女的最大（或者最小）元素</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>可以进行随机查找（方式同B树一样，从根结点开始），但是在非子树上的只能是索引，只会找到叶子结点才会停止</li><li>可以进行顺序查找，直接从最左叶子结点开始，适合带有范围的查找</li></ul><h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><p>同B树类似，不过全体在叶子结点进行</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2022/07/03/er-cha-shu-cha-zhao/"/>
      <url>/2022/07/03/er-cha-shu-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有序线性存储表(顺序存储)，在<strong>查找</strong>方面有效率的优势，但是在<strong>插入</strong>和<strong>删除</strong>方面，却选哟花费大量时间。为了照顾插入和删除的效率，同时实现高效率的查找算法，我们引入了二叉树。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉查找树</strong>又称之为<strong>二叉排序树</strong>，它可以为空树，也可以是具有以下特征的二叉树</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它根节点的值</li><li>若右子树不空，则右子树上所有结点的值均大于它根结点的值</li><li>左右子树也为二叉树</li><li>没有键值相等的点</li></ul><p><strong>（越往左越小）</strong></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从某node开始查找，如果目标值小于结点，则往左查找；如果目标值大于结点，往右查找。</p><p>一直找到叶子结点没有找到，返回false</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//伪码 使用递归</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 一直找到叶子节点，还没有找到就返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// 一条路径查找</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment">// 如果找到就返回true</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得知查找一个值为固定的一条路线，效率较高（理论上100的数据量，找到目标值最多需要7次）</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在查找的基础上，找到叶子结点</p><ul><li>如果插入的值等于叶子结点，返回false</li><li>如果插入值大于叶子结点，生成该叶子节点的右侧子树（反之亦然）</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>请神容易送神难，查找到目标结点容易。若是目标结点拥有子孙后代，删除该结点，就会让子孙树游离，原本的对应的关系不正确了。</p><p>删除结点有以下几种情况</p><ol><li>叶子结点</li><li>仅有左或右树结点</li><li>左右树都有的结点</li></ol><p><strong>第一种情况</strong></p><p>直接查找到该结点删除</p><p><strong>第二种情况</strong></p><p>查找到目标结点，其子树替补该位置</p><p><strong>第三种情况</strong></p><p>删除方法主要的概念是<strong>找删除结点前驱结点替换的方法</strong>（后继结点的方法也雷同）</p><ul><li>找到删除结点前驱结点中<strong>数值</strong>最接近的结点childNode（左树值最大结点）</li><li>目标结点的值 = childNode值</li><li>删除childNode(如果有且仅仅会有左子树，替补childNode位置)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉树查找的性能取决于该树的形状，其中比较值为目标结点所在的层数（深度），时间复杂度为：<em><strong>O（logn）</strong></em></p><p>在极度极端情况下，二叉树仅仅只有左树（或者右树），相当于遍历线性表，即顺序查找，时间复杂度为：<em><strong>O(n)</strong></em></p><p>因此我们更希望二叉树是一个平衡的树，即引出了平衡二叉树</p><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p><strong>平衡二叉树：</strong>属于一种二叉排序树，其中每一个结点的左子树和右子树的高度差最多为1</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>平衡因子BF(balance factor)：</strong>二叉树上结点左树的高度减去右树的高度（0，-1，1）</p><p><strong>最小不平衡树：</strong>距离插入结点最近的，<code>平衡因子绝对值大于1</code>的结点的子树</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>插入是否破坏平衡？<ul><li>若否 插入</li><li>若是 <ol><li>找出最小不平衡树</li><li>在不破坏二叉树特性的情况下，调整最小不平衡树中各节点的连接关系</li><li>进行旋转，成为新的平衡树</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象浅见</title>
      <link href="/2022/07/01/mian-xiang-dui-xiang-qian-jian/"/>
      <url>/2022/07/01/mian-xiang-dui-xiang-qian-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象（OO）"><a href="#面向对象（OO）" class="headerlink" title="面向对象（OO）"></a>面向对象（OO）</h1><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>类：封装对象属性和行为</li><li>方法：封装一定的业务逻辑功能</li><li>访问控制修饰符：封装具体的访问权限</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>作用：代码复用</p></li><li><p>超类：所有派生类共有的属性和行为</p><p>接口：部分派生类共有的属性和行为</p><p>派生类:派生类特有的属性和行为</p></li><li><p>单一继承、多接口实现，具有传递性</p></li></ul><ol><li>代码复用，通过extends来实现继承方法</li></ol><ul><li><p>派生类可以访问：派生类的+超类的   </p></li><li><p>超类不能访问派生类的</p><p>规定：构造派生类之前必须先构造超类</p></li></ul><ol start="2"><li><p>派生类构造中若不调用超类构造，则默认super()调超类无参构造</p></li><li><p>super：指当当前对象的超类对象</p></li></ol><p>super.成员变量名—————————访问超类的成员变量</p><p>super.方法名()——————————–调用超类的方法</p><p>super()——————————————调用超类的构造方法</p><p>补充</p><ul><li>super 和 this 不能同时调用方法</li><li>类属于引用数据类型</li><li>类里面不赋值，默认值即为数组的默认值（整型 0，引用 null，布尔false，浮点型0.0）</li><li>new n个  对象往往不会在for里面</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>意义：</p><ul><li><p>同一个对象被造型为不同的类型时，有不同的功能</p><p>—对象多态：我、你、水——————-所有对象都是多态的(明天再详细讨论)</p></li><li><p>同一类型的引用指向不同的对象时，有不同的实现</p><p>—行为多态：cut()，move()，getImage()……———所有抽象方法都是多态的</p></li></ul></li><li><p>向上造型：</p><ul><li>超类型的引用指向派生类的对象</li><li>能点出来什么，看引用的类型</li><li>能造型成为的类型有：超类+所实现的接口</li></ul></li><li><p>强转类型转换，成功的条件只有如下两种：</p><ul><li>引用所指向的对象，就是该类型</li><li>引用所指向的对象，实现了该接口或继承了该类</li></ul></li><li><p>强转时若不满足如上条件，则发生ClassCastException类型转换异常</p><p>建议：在强转之前先通过instanceof来判断引用指向的对象是否是该类型</p></li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>现实生活中有很多对象组成，基于对象抽出了类</p><ul><li><p>对象：软件中真是存在的单个个体，具有不同的属性</p><p>类：一类个体</p></li></ul><p>一般有几个对象，我们专门为此创建几个类   </p><ul><li><p>对象为具体，类为模子，一个类可以创建多个对象</p></li><li><p>类中包含</p><ul><li>对象的属性/特征——成员变量</li><li>对象的行为/动作/功能——方法（同一个类不能相同的方法签名）</li></ul></li><li><p>成员变量会默认初始值</p></li></ul><h3 id="this用法"><a href="#this用法" class="headerlink" title="this用法"></a>this用法</h3><ol><li><p>this：指代当前对象，哪个对象调用方法它指的就是哪个对象</p><p>​          只能用在方法中，方法中访问成员变量之前默认有个this.</p><p>this的用法：</p><ul><li><p>this.成员变量名————–访问成员变量</p><blockquote><p>当成员变量和局部变量同名时，若想访问成员变量则this不能省略，其它一般省略</p></blockquote></li><li><p>this.方法名()——————调用方法(一般不用，了解)</p></li><li><p>this()—————————-调用构造方法(一般不用，了解)</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token comment">//成员变量</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token comment">//构造方法</span>    <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token class-name">String</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>       <span class="token comment">//zs.name="zhangsan"</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>         <span class="token comment">//zs.age=25</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span> <span class="token comment">//zs.address="LF"</span>    <span class="token punctuation">}</span>    <span class="token comment">//实例方法</span>    <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"在学习..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁了，家住"</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//构造方法和this的演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//Student zs = new Student(); //编译错误，Student类没有无参构造</span>        <span class="token class-name">Student</span> zs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token string">"LF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> ls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token string">"JMS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        zs<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ls<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="方法和对象"><a href="#方法和对象" class="headerlink" title="方法和对象"></a>方法和对象</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法：构造函数、构造器、构建器—————-复用给成员变量初始化代码</p><ul><li><p>作用：给成员变量赋初始值</p></li><li><p>与类同名，没有返回值类型(连void都没有)</p></li><li><p>在创建(new)对象时被自动调用</p></li><li><p>若自己不写构造方法，则编译器默认提供一个无参构造方法，</p><p>若自己写了构造方法，则不再默认提供</p></li><li><p>构造方法可以重载</p></li></ul><p>补充</p><ul><li><p>行参：声明方法变量时</p><p>实参：调用方法时</p></li><li><p>方法签名：方法名+参数列表</p></li></ul><h3 id="方法的重载（overload）"><a href="#方法的重载（overload）" class="headerlink" title="方法的重载（overload）"></a>方法的重载（overload）</h3><ul><li>发生在同一类中，方法名相同，参数列表不同</li><li>编译器会根据参数列表的不同自动选择方法</li></ul><h3 id="方法的重写（override）"><a href="#方法的重写（override）" class="headerlink" title="方法的重写（override）"></a>方法的重写（override）</h3><ul><li><p>父子类中，方法名相同，参数列表相同（方法签名相同）</p></li><li><p>在运行时只走子类（new 的 对象）</p></li></ul><p>重写需遵循”两同两小一大”原则：</p><ul><li><p>两同：</p><ul><li>方法名相同</li><li>参数列表相同</li></ul></li><li><p>两小：</p><ul><li>派生类方法的返回值类型小于或等于超类方法的<ul><li>void和基本类型时，必须相等</li><li>引用类型时，可以小于或等于</li></ul></li><li>派生类方法抛出的异常小于或等于超类方法的————API时再说</li></ul></li><li><p>一大：</p><ul><li>派生类方法的访问权限大于或等于超类方法的</li></ul><p>补充: 静态方法不能被重写</p></li></ul><h3 id="方法的向上造型"><a href="#方法的向上造型" class="headerlink" title="方法的向上造型"></a>方法的向上造型</h3><ul><li>左边为超类容器，右边为派生类的参数</li><li>只能调用超类的数据、方法</li></ul><p>官方</p><ul><li>超类型的引用指向派生类的对象</li><li>能点出来什么，看引用的类型</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 做中餐 <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment">//1)我还是想做中餐-------------不需要重写</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//2)我想改做西餐---------------需要重写</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 做西餐 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3)我想在中餐之上加入西餐-------需要重写(先super中餐，再加入西餐)</span><span class="token keyword">class</span> <span class="token class-name">Aoo</span> <span class="token keyword">extends</span> 餐馆<span class="token punctuation">{</span>    <span class="token keyword">void</span> 做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>做餐<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">+</span> 做西餐    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​abstract修饰，只有方法的定义，没有具体的实现(连{}都没有)</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract修饰，包含抽象方法的类必须是抽象类，不能被实例化</p><p>​    需要被继承，派生类：重写所有抽象方法</p><p>​封装共有的属性和行为—-代码复用     为所有派生类提供统一的类型—–向上造型</p><p>​    为所有派生类提供统一的入口(能点出来)，强制必须重写</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>一种引用数据类型，一种标准</p></li><li><p>由interf来定义（非修饰）</p></li><li><p>只包含常量和抽象方法</p></li><li><p>不能被new对象，不能实例化</p></li><li><p>接口是要被实现（implements）的，实现/派生类：必须重写所有抽象方法，必须加关键字public</p></li><li><p>一个类可以实现多个接口，用逗号分隔。若又继承又实现，先继承再实现</p></li><li><p>接口可以继承接口</p><p>补充</p><ul><li>类和类                继承</li><li>接口和接口        继承</li><li>类和接口            实现</li></ul></li></ul><h3 id="内外部类"><a href="#内外部类" class="headerlink" title="内外部类"></a>内外部类</h3><ol><li><p>成员内部类：应用率低</p><ul><li><p>类中套类，外面的称为外部类，里面的称为内部类</p></li><li><p>内部类通常只服务于外部类，对外不具备可见性</p></li><li><p>内部类对象通常在外部类中创建</p></li><li><p>内部类中可以直接访问外部类的成员(包括私有的)</p><p>内部类中有个隐式的引用指向了创建它的外部类对象—外部类名.this——API时会用</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClassDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Mama</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mama</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//Baby b = new Baby(); //编译错误，内部类对外不具备可见性</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Mama</span><span class="token punctuation">{</span> <span class="token comment">//外部类</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Baby</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Baby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Baby</span><span class="token punctuation">{</span> <span class="token comment">//内部类</span>        <span class="token keyword">void</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Mama</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Mama.this指代当前对象的外部类对象</span>            <span class="token comment">//System.out.println(this.name); //编译错误，this指代当前Baby对象</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>匿名内部类：重点—————–大大简化代码</p><ul><li>若想创建一个类(派生类)的对象，并且对象只被创建一次，可以做成匿名内部类</li><li>匿名内部类中不能修饰外面局部变量的值，因为在此处该变量会默认为final的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnonInnerClassDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//new Aoo(); //创建Aoo对象</span>        <span class="token comment">//new Aoo(){}; //创建Aoo的派生类的对象</span>        <span class="token comment">//1)创建了Aoo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o1</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Aoo</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//向上造型</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//1)创建了Aoo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o2</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Aoo</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        num <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>        <span class="token comment">//1)创建了Boo的一个派生类，但是没有名字</span>        <span class="token comment">//2)为该派生类创建了一个对象，名为o3</span>        <span class="token comment">//3)大括号中的为派生类的类体</span>        <span class="token class-name">Boo</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//重写Boo类的抽象方法</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"showshow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//num = 66; //编译错误，在此处会默认num为final的---API时会用</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        o3<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Boo</span><span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Aoo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="修饰关键词"><a href="#修饰关键词" class="headerlink" title="修饰关键词"></a>修饰关键词</h3><ol><li><p>package</p><ul><li>避免类冲突</li><li>同包中类不可以同名，不同包的类可以</li><li>类的全称包名.类名</li><li>建议所有包名小写</li></ul></li><li><p>impor</p><ul><li>同包中导入类，可以用<ul><li>不同包导入类，需要导入包</li><li>或者引用类的全称</li></ul></li></ul></li><li><p>访问控制符（导入包 不起作用）</p><ul><li><p>public              公开的</p></li><li><p>protected       本类 派生类 同包类</p></li><li><p>默认（不写） 本类 同包类  ——不建议</p></li><li><p>private            本类</p></li></ul></li><li><p>finall：最终的、不可更改的——单独利用率低</p><ul><li>修饰变量：变量不能被改变，为常量</li><li>修饰方法：方法不能被重写</li><li>修饰类：    类不能被继承</li></ul></li><li><p>static ：静态变量</p><ul><li>属于类</li></ul><p>​      成员变量分为两种</p><ul><li>实例变量：没有static修饰，属于对象的，存储在堆中，有几个对象就有几个实例变量</li></ul><p>​      需要通过引用打点来访问</p><ul><li><p>静态变量：</p><ul><li><p>由static修饰，属于类，存储在方法区中，只有一份</p></li><li><p>通过类名打点来访问</p></li><li><p>何时用：所有对象需要共享的数据（图片，音频，视频）</p></li></ul></li><li><p>静态方法：</p><ul><li>前两条同上</li><li>static将方法体隐式的this删去，不能直接访问实例成员（即静态方法只能访问静态成员）</li><li>何时用：方法操作和对象无关（不需要访问对象</li></ul></li><li><p>静态块</p><ul><li>由static修饰</li><li>属于类，在类加载的时候自动执行，一个类只加载一次，所以静态块也加载一次</li><li>何时用：初始化/加载静态资源（图片、音频、视频）</li></ul></li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span>    语句块<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li><p>static final(常量)</p><ul><li>必须声明同时初始化</li><li>由类名来访问</li><li>存储在常量池中，常量池存储在堆中</li><li>建议：常量名所有字母大写，多个单词用_分隔</li><li>编译器在编译时会将常量直接替换为具体的值，效率高</li></ul></li></ol><ul><li>何时用：数据永远不变且经常使用，例如状态</li></ul><h2 id="String类（举例）"><a href="#String类（举例）" class="headerlink" title="String类（举例）"></a>String类（举例）</h2><ul><li>java.lang.String 用final修饰，不能被继承（java.lang包可以直接引用）</li><li>采用Unicode编码，一个字符2字节</li><li>底层封装了字符的数组</li><li>字符串一旦创建，对象的内容永远无法改变，但字符串的引用可以重新赋值——不变对象</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li><p>java对字符串的优化措施：常量池（堆中）</p></li><li><p>推荐使用字面量/直接量来创建字符串，并且会缓存所有以字面量形式创建的字符串对象到常量池中，当使用相同字符量在创建字符串会重用对象以减少内存开销</p></li><li><p>用来存放字符串的地址 ，指向非常量池中的堆中</p></li><li><p>只能通过字面量相连才会复用，不用使用引用的对象名</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 以上创建了几个对象</span><span class="token comment">/** * 答 2个 * 第一个： 字面量“hello” * 创建一个字面量对象表示“hello”，并将其存入常量池* 第二个：* new String() 时会再创建一个字符串对象， */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>对象名.length（）： 获取字符串长度，return int</p></li><li><p>对象名.trim（）： 去除当前字符串两边的空白字符，return一个新对象</p></li><li><p>对象名.toUpperCase（）：将当前符号中的英文转换为全大写</p><p>对象名.toLowerCase（）：将当前符号中的英文转换为全小写</p><p>全部return String</p></li><li><p>对象名.startsWith（”sth”）：判断字符串是否以”sth“ 开头，return boolea类型</p><p>对象名.endsWith（”sth”）：判断字符串是否以” sth “ 结尾，return boolea类型</p><p>区分大小写</p></li><li><p>对象名.charAt(int index) : 返回下标处的字符，return char</p></li><li><ol><li><p>对象名.indexOf(String str ) :检索str在String开始的下标，return int</p></li><li><p>对象名.indexOf(String str, int fromIndex ) :检索str在String从下标”fromIndex“以后的下标，return int。其中return的值为差值</p></li><li><p>对象名.lastIndexOf(String str): 检索str在String最后一次的下标，return int</p></li></ol><p>若找不到目标字符串，返回-1</p></li><li><p>对象名.substring(int a,int b)  ：截取下标 a到 b 之间的字符串  return String</p><p>对象名.substring(int a)           ：截取从下标a一直到末尾， return String</p></li><li><p>String.valueOf(a):将基本数据类型a所代表的值转换为String，return String</p></li></ul><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ul><li><p>由于String是不变对象，每次修改内容要创建新对象，因此String不适合做频繁修改操作，为了解决这个问题，java提供了StringBuilder类。</p></li><li><p>StringBuilder是专门用于修改字符串的一个API，内部维护一个可变的char数组，修改都是在这个数组上进行的，修改速度、性能优秀，并且提供了修改字符串的常见的方法：增、删、改、插</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//String不适合频繁修改内容</span><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s <span class="token operator">=</span> s<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用StringBuilder可以提高修改字符串的性能</span><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>StringBuilder常用方法：</p><ul><li>append()：追加内容</li><li>replace()：替换部分内容</li><li>delete()：删除部分内容</li><li>insert()：插入内容</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"好好学习java"</span><span class="token punctuation">;</span><span class="token comment">//复制str中的内容到builder中-----好好学习java</span><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append():追加内容</span>builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"，为了找个好工作!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//好好学习java，为了找个好工作!</span><span class="token comment">//replace():替换部分内容</span>builder<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">"就是为了改变世界"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//替换下标9到15的</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//好好学习java，就是为了改变世界!</span><span class="token comment">//delete():删除部分内容</span>builder<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除下标0到7的</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//，就是为了改变世界!</span><span class="token comment">//insert():插入操作</span>builder<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"活着"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从下标0的位置插入</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//活着，就是为了改变世界!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(概述、应用层、运输层)</title>
      <link href="/2022/07/01/ji-suan-ji-wang-luo-zi-ding-er-xia-de-fang-fa/"/>
      <url>/2022/07/01/ji-suan-ji-wang-luo-zi-ding-er-xia-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-自顶而下的方法"><a href="#计算机网络-自顶而下的方法" class="headerlink" title="计算机网络 自顶而下的方法"></a>计算机网络 自顶而下的方法</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><ul><li><p>应用层 ：是对应用到应用的抽象</p></li><li><p>运输层 ：提供socket 到 socket的抽象接口</p></li><li><p>网络层 ：提供主机到主机的抽象接口</p></li><li><p>链路层 ：线缆的抽象接口</p></li><li><p>物理层 ：发生在物理线路</p></li></ul><h3 id="1-第五层——应用层-application-layer"><a href="#1-第五层——应用层-application-layer" class="headerlink" title="1 第五层——应用层(application layer)"></a>1 第五层——应用层(application layer)</h3><ul><li><strong>应用层(application layer)：</strong>是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。</li><li>在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。</li></ul><h3 id="2-第四层——运输层-transport-layer"><a href="#2-第四层——运输层-transport-layer" class="headerlink" title="2. 第四层——运输层(transport layer)"></a>2. 第四层——运输层(transport layer)</h3><ul><li><strong>运输层(transport layer)：</strong>负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</li><li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li><li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li><li><strong>运输层主要使用以下两种协议：</strong><br><strong>(1) 传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br><strong>(2) 用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li></ul><h3 id="3-第三层——网络层-network-layer"><a href="#3-第三层——网络层-network-layer" class="headerlink" title="3. 第三层——网络层(network layer)"></a>3. 第三层——网络层(network layer)</h3><ul><li><strong>网络层(network layer)主要包括以下两个任务：</strong></li><li><strong>(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</strong></li><li><strong>(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</strong></li><li><strong>协议：IP,ICMP,IGMP,ARP,RARP</strong></li></ul><h3 id="4-第二层——数据链路层-data-link-layer"><a href="#4-第二层——数据链路层-data-link-layer" class="headerlink" title="4. 第二层——数据链路层(data link layer)"></a>4. 第二层——数据链路层(data link layer)</h3><ul><li><strong>数据链路层(data link layer)：</strong>常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。</li><li>每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</li><li>注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。<br>(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。<br>(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</li></ul><h3 id="5-第一层——物理层-physical-layer"><a href="#5-第一层——物理层-physical-layer" class="headerlink" title="5. 第一层——物理层(physical layer)"></a>5. 第一层——物理层(physical layer)</h3><ul><li><strong>物理层(physical layer)：</strong>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</li></ul><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>  <img src="https://user-images.githubusercontent.com/105496252/176896116-5d70b5a9-4b4a-42fd-a990-39e394104e5c.jpg"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>RTT（Round Trip Time）：往返时延，也就是<strong>数据包从发出去到收到对应 ACK 的时间。</strong>RTT 是针对连接的，每一个连接都有各自独立的 RTT。</p></li><li><p>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</p></li><li><p>TCP超时重传： 如果发送方认为发生了丢包现象，就重发这些数据包，接收方每收到一个包，就向发送方返回一个 <strong>ACK</strong>，表示自己已经收到了这段数据，反过来，如果发送方一段时间内没有收到 ACK，就知道<strong>很可能</strong>是数据包丢失了，紧接着就重发该数据包，直到收到 ACK 为止。 </p></li><li><p>传播时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> </p></li><li><p>传输时间： <em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em></p></li></ul><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="1英特网"><a href="#1英特网" class="headerlink" title="1英特网"></a>1英特网</h3><h3 id="2网络边缘"><a href="#2网络边缘" class="headerlink" title="2网络边缘"></a>2网络边缘</h3><ul><li><p>住宅接入：DSL、电缆、FTTH、卫星、拨号接入（拨号调制解调器）、以太网、WiFi等<br>公司接入：以太网、WiFi等<br>广域无线接入：3G、4G、LTE等 </p></li><li><p>拨号调制解调器：最高速度为 56 Kbps，专用的<br>HFC：高达 42.8 Mbps 下行速率和高达 30.7 Mbps 的上行速率，共享的<br>DSL：最高 24 Mbps 下行速率和最高 2.5 Mbps 上行速率，专用的<br>FTTH: 最高 4Mbps 上行，100Mbps 下行速率，专用的</p></li></ul><h3 id="3交换机链路系统"><a href="#3交换机链路系统" class="headerlink" title="3交换机链路系统"></a>3交换机链路系统</h3><ul><li>电路交换网络预留了宽带，传统的电路交换分离出单个信号需要多个滤波器</li><li>谷歌使用专门网络避开高层ISP，获得更好的用户体验和公司的流量运输费用</li></ul><h3 id="4数据传输"><a href="#4数据传输" class="headerlink" title="4数据传输"></a>4数据传输</h3><ul><li>处理时延，排队时延，传输时延，传播时延。<br> 除了排队时延之外都是固定的 </li><li>传送文件的吞吐量一般为途径链路的最小速度</li><li>流量强度=最大速度/最小速度</li><li>数据包传输具有随机性</li></ul><h4 id="传播时延和传输时延"><a href="#传播时延和传输时延" class="headerlink" title="传播时延和传输时延"></a>传播时延和传输时延</h4><p>假设AB间速率为Rbps，相隔M米，链路的传播速度s m/s，发送L比特长度文件</p><ul><li>传播时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> </li><li>传输时间： <em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em> </li><li>端到端的时延： <em>d<strong>p</strong>r<strong>o</strong>p</em>=<em>m</em>/<em>s</em> +<em>d<strong>t</strong>r<strong>a</strong>ns</em>=<em>L</em>/<em>R</em>   （去除其他时延）</li></ul><h3 id="5协议层次和模型"><a href="#5协议层次和模型" class="headerlink" title="5协议层次和模型"></a>5协议层次和模型</h3><h4 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h4><p>5个</p><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p>路由器</p><p> 路由器处理网络层、链路层、物理层，链路层（现代的路由器有可能会担当防火墙或缓存，因此可能会处理运输层）。交换机处理链路层。主机处理所有五个层次。 </p><h3 id="6面对的网络攻击"><a href="#6面对的网络攻击" class="headerlink" title="6面对的网络攻击"></a>6面对的网络攻击</h3><p> 病毒是需要用户交互来感染用户设备的恶意软件；蠕虫无需用户交互。                  </p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="万维网应用"><a href="#万维网应用" class="headerlink" title="万维网应用"></a>万维网应用</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>拉的作用</p><h3 id="电子邮件应用"><a href="#电子邮件应用" class="headerlink" title="电子邮件应用"></a>电子邮件应用</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>推的作用</p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>负责邮件下载——删除——转移存储</p><h3 id="文件传送"><a href="#文件传送" class="headerlink" title="文件传送"></a>文件传送</h3><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>​       FTP使用两个并行的TCP连接，一个用于发送控制信息(比如传输文件的请求)，另一个用于实际传输文件。因为控制信息不是通过发送文件的同一连接发送的，所以说FTP在带外发送控制信息 </p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p> DNS就是把域名解析为IP地址，提供我们上网，我们能够上网最终是找到IP地址。 </p><p>修改DNS的好处</p><ol><li>适当提高上网速度；</li><li>更换DNS可以访问某些因为域名解析存在问题而不能访问的网站；</li><li>可以屏蔽运营商的广告，还可以帮助您避免被钓鱼的危险；</li></ol><p>修改DNS带来的副作用</p><ol><li>无法访问页面或者访问的页面不是你想要的页面；</li><li>访问速度没有你从运营商处获得的DNS访问分速度快，延时比较大；</li><li>·受到DNS劫持，插入广告和被钓鱼网站攻击；</li></ol><p>注释：一个网站可有有多个域名，对应不同IP地址</p><h4 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h4><p>我为人人，人人为我</p><p>例子 : 迅雷BT种子</p><h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>多路复用：家里某人收集众人邮件给邮递员</p><p>分解：邮递员把文件包给家中某人，其将包裹分解分发给家人</p><p>纠错检验功能：TCP相对比较复杂，UDP比较简单</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>拥有拥塞控制、顺序控制、超时重传等等功能，因为套字相对于UDP比较多，速度相对较慢。</p><p>适合于大文件、要求文件传输完整性的传输。</p><p>需要两个套接字</p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>就是两个通信实体在互相发送数据之前首先交换控制数据包。SMTP在应用层使用握手协议，而HTTP没有。 </p><ul><li><p>三次握手，第四次携带请求下载的信息</p></li><li><p>非连续TCP </p><p>​       重新三次握手</p></li><li><p>连续TCP</p><p>​        后续 第二次请求即以后仅仅需要发送请求（1），得到回复信息（2），不需要两次握手</p><ul><li>串联  重新考虑传播消耗</li><li>并联  均分速率，避开传播消耗</li></ul></li></ul><h4 id="自动重传请求（ARQ）"><a href="#自动重传请求（ARQ）" class="headerlink" title="自动重传请求（ARQ）"></a>自动重传请求（ARQ）</h4><p>需要协同的协议</p><ul><li>差错检测 额外的比特在报文中</li><li>接收方反馈</li><li>重传</li></ul><p>滑动窗口传输协议（GBN）</p><ul><li>多分组以窗口传送</li><li>接收方接收到受损分组主动丢失该窗口的N个分组（减少接收方缓存）</li><li>回复ACK1或0（1、0交替）为确认，NAK为未收到；同时也存在ACK答复报文的丢失</li><li>发送方式 0123—1234——2345-—3456——error2——2345</li></ul><p>选择重传（SR）</p><ul><li>失去ack序号的组等待重传，其他正确的窗口内的组在接收方等待缓存，待ACK全部达到，进行性下一步、</li><li>协议长度过长将无法工作，必须小于等于序号空间的一半</li></ul><p>拥塞控制</p><ul><li><p>慢启动</p><p>发送速率cwnd为MSS/RTT，以后每过一个RTT成指数增长</p></li><li><p>拥塞避免</p><ul><li><p>当无法再增加一倍时，在一个RTT只增加一个MSS</p><p>即假设cwnd=10mss，每收到一个ack增加1/10个MSS</p></li></ul></li><li><p>快速回复</p><p>速度当收到3个冗余ack时，变为（一半+3个MSS）</p></li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>对UDP，事务可以在一次往返时间(RTT)中完成——客户端将事务请求发送到UDP套接字，服务器将应答发送回客户端的UDP套接字。对于TCP，至少需要两个RTTs—一个用于建立TCP连接，另一个用于客户端发送请求以及服务器发送回复。（鉴于TCP是面向连接，传输前要进行三次握手而UDP不需建立连接 没有拥塞机制</p><p>​      仅仅需要一个套接字</p><p>​     从应用层的来的数据装修（近似于和IP打交道），仅仅4个字段，8字节：</p><ul><li>多路分解/复用字段（源端口号/目的端口号）</li><li>长度</li><li>校验和（运输到目的地后校验）</li></ul><p>部分UDP可以在运输层的使用UDP，并在应用层使用特定协议保持数据可靠性（谷歌浏览器的quic，处于应用层）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>低延迟</li><li>报文段字节较少，仅仅8字节</li><li>无连接状态，不跟踪数据传输信息，可以支持更多活跃用户</li></ul><h4 id="纠错检验（端到端原则）"><a href="#纠错检验（端到端原则）" class="headerlink" title="纠错检验（端到端原则）"></a>纠错检验（端到端原则）</h4><p>四个16比特的字节之和为1111111111111111（16个1）</p><p>如果溢出则回卷，出现个别0</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础语法</title>
      <link href="/2022/07/01/java-ji-chu-yu-fa/"/>
      <url>/2022/07/01/java-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>​     数据类型                    关键字      包装类型   内存占用取值范围</p><ul><li>字节型                       byte            Byte        1个字节-128~127</li><li>短整型                       short          Short       2个字节-32768~32767</li><li>整型                       int              Integer    4个字节-2^31~2^31-1</li><li>长整型                       long(L)         Long      8个字节-2^63~2^63-1</li><li>单精度浮点数           float(F)         Float      4个字节38位</li><li>双精度浮点数           double(D)    Double  8个字节308位</li><li>字符型                       char            Character  2个字节0~65535</li><li>布尔类型                   boolean      Boolean 1个字节true,false</li></ul><p>※数据范围和字节数不一定相关。如float范围比long大，但字节数小。</p><p>※浮点数是一个近似值：double s =4.0-3.6; //打印s为：0.3999999999</p><p>  其本质是<strong>科学计数法</strong>,</p><ul><li>第一位符号位,表示正负,0为负,1为正数</li><li>中间8(11)位即阶码,用以存贮指数位置的值</li><li>最后23(52)位即尾数,用以精确表示数字的值,各自精确小数点后6-7(15-16)</li></ul><p><img src="https://user-images.githubusercontent.com/105496252/176885809-33432ccf-cce0-4529-9fe2-e21b706e9df5.png" alt="浮点数据类型比特位分配"></p><p>※Infinity：无穷大，除以0可得，5.0/0</p><p>※NAN：not a number， 0.0/0</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>只能包含                                <font color="red"> 字母 数字 _ $ </font></p><p>杜绝</p><ul><li>单个字母</li><li>中文（部分框架不允许）</li><li>中文拼音</li><li>不使用关键字</li></ul><p>建议</p><ul><li>小驼峰输入法 （第一个首字母不大写）   myScore， myJavaScore</li><li>大驼峰输入法（所有首字母都大写）</li><li>英文</li></ul><h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">如果参与运算的类型不一样，则自动转化为相同类型<span class="token keyword">char</span>\<span class="token keyword">byte</span>\<span class="token keyword">short</span><span class="token operator">--</span><span class="token keyword">int</span><span class="token operator">--</span><span class="token keyword">long</span><span class="token operator">--</span><span class="token keyword">float</span><span class="token operator">-</span>doubleint<span class="token operator">*</span><span class="token keyword">long</span><span class="token operator">=</span><span class="token keyword">long</span><span class="token operator">*</span><span class="token keyword">long</span>    <span class="token keyword">byte</span>、<span class="token keyword">char</span>、<span class="token keyword">short</span> 在参与运算时，一律为<span class="token keyword">int</span>计算结果会溢出溢出不会报错，自动重新填<span class="token punctuation">(</span>最大值加<span class="token number">1</span>为最小值<span class="token punctuation">)</span> <span class="token keyword">byte</span> b1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b2 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//4</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//52，2加上'2'的码50</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token operator">+</span><span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//100，'2'的码50，加上'2'的码50</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量取值最大数"><a href="#变量取值最大数" class="headerlink" title="变量取值最大数"></a>变量取值最大数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="强转数据类型"><a href="#强转数据类型" class="headerlink" title="强转数据类型"></a>强转数据类型</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span><span class="token keyword">byte</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token comment">//注意溢出误差、精度丢失</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="两点原则"><a href="#两点原则" class="headerlink" title="两点原则"></a>两点原则</h4><ul><li>整数直接量可以直接赋值给byte,short,char，但不能超出范围</li><li>byte,short,char型数据参与运算时，系统会将其自动转换为int再运算</li></ul><h4 id="转义符（char类型）"><a href="#转义符（char类型）" class="headerlink" title="转义符（char类型）"></a>转义符（char类型）</h4><p>特殊符号需要通过\来转义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token char">'女'</span><span class="token punctuation">;</span>  <span class="token comment">//字符女</span><span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token char">'f'</span><span class="token punctuation">;</span>  <span class="token comment">//字符f</span><span class="token keyword">char</span> c3 <span class="token operator">=</span> <span class="token char">'6'</span><span class="token punctuation">;</span>  <span class="token comment">//字符6</span><span class="token keyword">char</span> c4 <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>  <span class="token comment">//字符*</span><span class="token comment">//char c5 = 女; //编译错误，字符型直接量必须放在单引号中</span><span class="token comment">//char c6 = ''; //编译错误，单引号中必须有字符</span><span class="token comment">//char c7 = '25'; //编译错误，只能有一个字符</span><span class="token keyword">char</span> c8 <span class="token operator">=</span> <span class="token char">'\\'</span><span class="token punctuation">;</span> <span class="token comment">//\为特殊符号，需要通过\来转义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c8<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换变量（三个杯子原理）"><a href="#交换变量（三个杯子原理）" class="headerlink" title="交换变量（三个杯子原理）"></a>交换变量（三个杯子原理）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>b <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//首尾相连</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">if</span>语句                           <span class="token keyword">switch</span>语句<span class="token keyword">if</span><span class="token punctuation">(</span>关系表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token function">siwtch</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>语句体<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>关系表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">case</span> 常量值<span class="token number">1</span><span class="token operator">:</span> 语句体<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>语句体<span class="token punctuation">;</span>                        <span class="token keyword">case</span> 常量值<span class="token number">2</span><span class="token operator">:</span> 语句体<span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                           …语句体<span class="token punctuation">;</span>                        <span class="token keyword">default</span><span class="token operator">:</span>语句体n<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>                               <span class="token punctuation">}</span>          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>byte、short、int、char、String、枚举</p><p>在条件选择后以此为开始，向下贯穿。JAVA</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">普通<span class="token keyword">for</span>循环：    <span class="token keyword">for</span><span class="token punctuation">(</span>初始表达式<span class="token punctuation">;</span>布尔表达式<span class="token punctuation">;</span>步进表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>     循环体；<span class="token punctuation">}</span><span class="token keyword">while</span>循环：    初始表达式<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>条件判断<span class="token punctuation">)</span><span class="token punctuation">{</span>     循环体<span class="token punctuation">;</span>步进语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">do</span><span class="token operator">-</span><span class="token keyword">while</span>循环：初始表达式<span class="token punctuation">;</span>   <span class="token keyword">do</span><span class="token punctuation">{</span>     循环体<span class="token punctuation">;</span>      步进语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>条件判断<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>break：跳出循环———–可以用在switch和循环中</li><li>continue：跳过循环体中剩余语句而进入下一次循环——只能用在循环中</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><p>System.arraycopy(a,1,b,0,4);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//0,0,0,0,0,0</span><span class="token comment">//a:源数组</span><span class="token comment">//1:源数组的起始下标</span><span class="token comment">//b:目标数组</span><span class="token comment">//0:目标数组的起始下标</span><span class="token comment">//4:要复制的元素个数</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//灵活性好</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>int[] b = Arrays.copyOf(a,6);<br>a = Arrays.copyOf(a,a.length+1); //数组的扩容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//a:源数组</span><span class="token comment">//b:目标数组</span><span class="token comment">//6:目标数组的长度</span><span class="token comment">//----若目标数组的长度&gt;源数组长度，则在末尾补默认值</span><span class="token comment">//----若目标数组的长度&lt;源数组长度，则将末尾的截掉</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//数组的扩容</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//数组的扩容(创建了一个更大的新的数组，并将数据复制进去了)</span>a <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p>Arrays.sort(arr);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对arr进行升序排列</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"倒序输出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只是倒着显示，但数组中数据没有改变</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h3><ul><li>数组超过长度异常</li><li>空指针异常（NullPointerException）：栈上的变量为赋值null,指针被消除，与堆的联系中断</li></ul><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="定义五要素"><a href="#定义五要素" class="headerlink" title="定义五要素"></a>定义五要素</h3><ul><li><p>返回值可有（特定数据类型 int 、boolean、数组等等） 可无（void）</p></li><li><p>修饰词</p></li><li><p>方法名</p><p>见名字知意思</p></li><li><p>参数列表</p><ul><li>有参 传进去的为指针</li></ul><p>参数里面的数值表示引用，调用引用数据类型的地址和基本数据类型的地址</p><p>基本数据类型的值不能改变（改变为另一个声明，使用需要return）</p><p>应用数据类型不能改变对象，可以改变对象的值，数组的值</p></li><li><p>方法体</p></li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>方法：函数、过程</p><ul><li><p>封装一段特定的业务逻辑功能</p></li><li><p>尽可能独立，一个方法只干一件事</p></li><li><p>方法可以被反复调用多次</p></li><li><p>可以减少代码重复，有利于代码维护</p></li><li><p>何时用：假设有一个功能，在很多地方都得使用，就将功能封装到一个方法中</p></li><li><p>行参：声明方法变量时</p><p>实参：调用方法时</p></li></ul></li><li><p>方法的定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//无参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫WKJ，今年38岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//有参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//形参</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年38岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//有参无返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//形参</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"，今年"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//无参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//若方法有返回值，则在方法中必须出现return关键字</span>    <span class="token comment">//并且return后的数的类型必须与返回值类型匹配</span>    <span class="token comment">//return "abc"; //编译错误</span>    <span class="token keyword">return</span> <span class="token number">8.88</span><span class="token punctuation">;</span> <span class="token comment">//1)结束方法的执行  2)返回结果给调用方</span><span class="token punctuation">}</span><span class="token comment">//有参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span><span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> num1<span class="token operator">+</span>num2<span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span> <span class="token comment">//返回的是num里面的那个数</span>    <span class="token comment">//return num1+num2; //返回的是num1与num2的和</span><span class="token punctuation">}</span><span class="token comment">//无参有返回值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法的调用：</p><ul><li><p>无返回值：方法名(有参传参);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用say()方法</span>        <span class="token comment">//sayHi(); //编译错误，有参则必须传参</span>        <span class="token comment">//sayHi(250); //编译错误，参数类型必须匹配</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="zhangsan"  //实参</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="lisi"          //实参</span>        <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String name="wangwu"      //实参</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参 String name="zhangsan",int age=25</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有返回值：数据类型  变量  =  方法名(有参传参);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//方法的演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//getNum()的值就是return后的那个数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//8.88，模拟对返回值的后续操作</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//plus(5,6)的值就是return后的那个数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11，模拟对返回值的后续操作</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传递的是m和n里面的数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11，模拟对返回值的后续操作</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"长度为:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10，模拟对返回值的后续操作</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>d<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//模拟对返回值的后续操作</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>return：</p><ul><li>return 值;  //1) 结束方法的执行  2) 返回结果给调用方</li><li>return;       //1) 结束方法的执行</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_查找</title>
      <link href="/2022/07/01/xian-xing-suo-yin-cha-zhao/"/>
      <url>/2022/07/01/xian-xing-suo-yin-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><h2 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h2><p>查找表按照操作方式有两大种</p><ul><li>静态查找表:只做查找操作</li><li>动态查找表:查找过程中同时进行增删元素</li></ul><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p>又称为顺序查找,遍历元素进行查找,</p><ul><li>算法时间复杂度为<em><strong>O(n)</strong></em></li></ul><h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><p>通过分隔点的不同,引入三种算法</p><h4 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找(二分查找)"></a>折半查找(二分查找)</h4><ul><li><p>前提 : 关键码有序(通常从小到大)</p><p>​           线性表必须使用顺序存储</p><p>​   更适合静态查找表(动态需要在增删后维护) </p></li><li><p>方法 :  类似于二叉树查找,取中间值比较大小,进入下一区域</p><p>​           进一步在下一区域 ,取中值比较大小….循环 </p></li><li><p>时间复杂度 :  <em><strong>O(logn)</strong></em></p></li></ul><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul><li><p><strong>前提、时间复杂度</strong>近似于折半查</p></li><li><p>用法 : 类似于查找新华字典,会提前寻找一个大致字母的区域</p><p>​ 根据查找的关键词字key与查找表中的最大值与最小值的比较后查找</p><p><code>Mid = Begin + ( (End - Begin) / (A[End] - A[Begin]) ) * (X - A[Begin])</code></p><ul><li>Mid：计算得出的元素的位置；</li><li>End：搜索区域内最后一个元素所在的位置；</li><li>Begin：搜索区域内第一个元素所在的位置；</li><li>X：要查找的目标元素；</li><li>A[]：表示整个待搜索序列</li></ul></li><li><p>适用: 表较长,关键字分布比较均匀</p></li></ul><h4 id="斐波那切查找"><a href="#斐波那切查找" class="headerlink" title="斐波那切查找"></a>斐波那切查找</h4><p>算法核心</p><ul><li>斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</li><li>优势 :   <ol><li>查找以加法进行运算(插值为四则运算,折半为加法和除法)</li><li>时间复杂度虽然为 <em><strong>O(logn)</strong></em>,但平均性能大于折半(目标为1时为极端情况,会劣于前者)</li></ol></li></ul><h3 id="线性索引查找-1"><a href="#线性索引查找-1" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>针对海量数据,关键码也不一定按照有序排列,不能遍历或者半遍历元素，就引入了索引</p><ul><li>索引即为将一个关键字和它对应的记录关联的过程</li><li>分为<strong>线性</strong>、<strong>树形</strong>、<strong>多级</strong>索引，这里主要介绍线性索引</li></ul><p><strong>线性索引</strong>即为将索引项集合组织为线性结构，也陈之为索引表,重点介绍以下几种</p><ul><li>稠密索引</li><li>分块索引</li><li>倒排索引</li></ul><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p>数据的每一个记录对应一个索引项</p><p><img src="https://user-images.githubusercontent.com/105496252/176885763-b4d74a30-ec4a-47c6-9918-79d6b3b49035.jpg" alt="稠密索引"></p><ul><li><p>优点: 数据项是无序的,索引项是有序的</p><p>​          可以对索引项进行有序查找</p></li><li><p>缺点 : 每一次查询需要在磁盘中读取更多内存,数据庞大时(上亿级别)</p><p>​          查询性能反而下降</p></li></ul><h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p>类似如图书馆藏书管理体系.将数据集分成了若干块,各自建立索引项,指向各自的块内元素</p><ul><li><p>块内无序 : 理论上可以有序更好,但是需要花费不成正比的维护成本,故不做要求</p></li><li><p>快间有序 : 第N块所有元素的关键字永远<strong>全部</strong>小于第N+1块里的每个元素</p></li></ul><img src="https://user-images.githubusercontent.com/105496252/176885792-12a3eec1-28a8-4a32-9f6d-736ead78305e.png" alt="分块索引" style="zoom: 50%;"><p>最大关键码 : 每个块中关键字最大的元素关键码值</p><p>块长 : 每个块内元素的个数</p><p>块首指针 : 指向块首元素</p><ul><li>方法 : 在块间使用有序查找,在块内使用顺序查找(遍历)</li><li>时间复杂度 : ASL<sub>w</sub>=√n + 1  (介于顺序查找和折半查找之间)</li></ul><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>通用结构</p><ul><li>次关键码 : 类似于搜索引擎中的关键字</li><li>记录号表 : 类似于搜索引擎中对应出的整体文章标号(同一个关键词出现的次数)</li></ul><p>其中记录号表存储的具有相同次关键词的所有的记录的记录号(可以是指向记录的指针或者是该记录的关键字)</p><ul><li>优点 : 查找非常快</li><li>缺点 : 维护比较困难,每一个记录号都将对应好几个文章,插入删除需要额外的处理</li></ul><blockquote><p><strong>运用实例</strong></p><p>Elasticsearch : 功能类似一个数据库,能高效的从大量数据中搜索匹配指定关键字的内容.常常用于搜索</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构粗浏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2022/06/29/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2022/06/29/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
